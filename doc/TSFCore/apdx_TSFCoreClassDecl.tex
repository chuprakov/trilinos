%
\section{TSFCore C++ class declarations}
\label{app:tsfcore_classes}
%

{\scriptsize\begin{verbatim}
namespace TSFCore {

using RangePack::Range1D;
template<class Scalar> class VectorSpaceFactory;
template<class Scalar> class VectorSpace;
template<class Scalar> class Vector;
template<class Scalar> class OpBase;
template<class Scalar> class LinearOp;
template<class Scalar> class MultiVector;
template<class Scalar>

class VectorSpaceFactory {
public:
  virtual Teuchos::RefCountPtr< const VectorSpace<Scalar> > createVecSpc(int dim) const = 0;
};

template<class Scalar>
class VectorSpace {
public:
  virtual ~VectorSpace() {}
  virtual Index dim() const = 0;
  virtual bool isCompatible( const VectorSpace<Scalar>& vecSpc ) const = 0;
  virtual Teuchos::RefCountPtr< Vector<Scalar> > createMember() const = 0;
  virtual bool isInCore() const;
  virtual Teuchos::RefCountPtr< MultiVector<Scalar> > createMembers(int numMembers) const;
  virtual Teuchos::RefCountPtr<Vector<Scalar> > createMemberView(
            const RTOpPack::MutableSubVectorT<Scalar> &raw_v ) const;
  virtual Teuchos::RefCountPtr<const Vector<Scalar> > createMemberView(
            const RTOpPack::SubVectorT<Scalar> &raw_v ) const;
  virtual Teuchos::RefCountPtr<MultiVector<Scalar> > createMembersView(
            const RTOpPack::MutableSubMultiVectorT<Scalar> &raw_mv ) const;
  virtual Teuchos::RefCountPtr<const MultiVector<Scalar> > createMembersView(
            const RTOpPack::SubMultiVectorT<Scalar> &raw_mv ) const;
  virtual Teuchos::RefCountPtr< const VectorSpaceFactory<Scalar> > smallVecSpcFcty() const;
  virtual Scalar scalarProd( const Vector<Scalar>& x, const Vector<Scalar>& y ) const;
  virtual void scalarProds( const MultiVector<Scalar>& X, const MultiVector<Scalar>& Y
    ,Scalar scalar_prods[] ) const;
  virtual Teuchos::RefCountPtr< const VectorSpace<Scalar> > clone() const;
};

template<class Scalar>
class OpBase {
public:
  virtual ~OpBase();
  virtual Teuchos::RefCountPtr< const VectorSpace<Scalar> > domain() const = 0;
  virtual Teuchos::RefCountPtr< const VectorSpace<Scalar> > range() const = 0;
  virtual bool opSupported(ETransp M_trans) const;
};

template<class Scalar>
class LinearOp : virtual public OpBase<Scalar> {
public:
  virtual void apply( const ETransp M_trans, const Vector<Scalar> &x
    ,Vector<Scalar> *y ,const Scalar alpha=1.0 ,const Scalar beta=0.0 ) const = 0;
  virtual Teuchos::RefCountPtr<const LinearOp<Scalar> > clone() const;
  virtual void apply( const ETransp M_trans ,const MultiVector<Scalar> &X
    ,MultiVector<Scalar> *Y ,const Scalar alpha=1.0 ,const Scalar beta=0.0 ) const;
};

template<class Scalar>
class MultiVector : virtual public LinearOp<Scalar> {
public:
  virtual Teuchos::RefCountPtr<const Vector<Scalar> > col(Index j) const;
  virtual Teuchos::RefCountPtr<Vector<Scalar> > col(Index j) = 0;
  virtual Teuchos::RefCountPtr<const MultiVector<Scalar> > clone_mv() const;
  virtual Teuchos::RefCountPtr<MultiVector<Scalar> > clone_mv();
  virtual Teuchos::RefCountPtr<const MultiVector<Scalar> > subView( const Range1D& col_rng ) const;
  virtual Teuchos::RefCountPtr<MultiVector<Scalar> > subView( const Range1D& col_rng );
  virtual Teuchos::RefCountPtr<const MultiVector<Scalar> > subView( const int numCols, const int cols[] ) const;
  virtual Teuchos::RefCountPtr<MultiVector<Scalar> > subView( const int numCols, const int cols[] );
  virtual void applyOp( const RTOpPack::RTOpT<Scalar> &primary_op, const size_t num_multi_vecs
    ,const MultiVector<Scalar>* multi_vecs[], const size_t num_targ_multi_vecs
    ,MultiVector<Scalar>* targ_multi_vecs[], RTOpPack::ReductTarget* reduct_objs[], const Index primary_first_ele
    ,const Index primary_sub_dim,const Index primary_global_offset, const Index secondary_first_ele
    ,const Index secondary_sub_dim ) const;
  virtual void applyOp( const RTOpPack::RTOpT<Scalar> &primary_op, const RTOpPack::RTOpT<Scalar> &secondary_op
    ,const size_t num_multi_vecs, const MultiVector<Scalar>* multi_vecs[], const size_t num_targ_multi_vecs
    ,MultiVector<Scalar>* targ_multi_vecs[], RTOpPack::ReductTarget* reduct_obj, const Index primary_first_ele
    ,const Index primary_sub_dim, const Index primary_global_offset, const Index secondary_first_ele
    ,const Index secondary_sub_dim ) const;
  virtual void getSubMultiVector( const Range1D &rowRng, const Range1D &colRng
    ,RTOpPack::SubMultiVectorT<Scalar> *sub_mv ) const;
  virtual void freeSubMultiVector( RTOpPack::SubMultiVectorT<Scalar>* sub_mv ) const;
  virtual void getSubMultiVector( const Range1D &rowRng, const Range1D &colRng
    ,RTOpPack::MutableSubMultiVectorT<Scalar> *sub_mv	);
	virtual void commitSubMultiVector( RTOpPack::MutableSubMultiVectorT<Scalar>* sub_mv );
  void apply( const ETransp M_trans, const Vector<Scalar> &x, Vector<Scalar> *y, const Scalar alpha
    ,const Scalar beta ) const;
  Teuchos::RefCountPtr<const LinearOp<Scalar> > clone() const;
};

template<class Scalar>
class Vector : virtual public MultiVector<Scalar> {
public:
  virtual ~Vector() {}
  virtual Teuchos::RefCountPtr< const VectorSpace<Scalar> > space() const = 0;
  virtual void applyOp( const RTOpPack::RTOpT<Scalar> &op, const size_t num_vecs
    ,const Vector<Scalar>* vecs[], const size_t num_targ_vecs ,Vector<Scalar>* targ_vecs[]
    ,RTOpPack::ReductTarget *reduct_obj ,const Index first_ele ,const Index sub_dim
    ,const Index global_offset ) const = 0;
  virtual void getSubVector( const Range1D& rng, RTOpPack::SubVectorT<Scalar>* sub_vec ) const;
  virtual void freeSubVector( RTOpPack::SubVectorT<Scalar>* sub_vec ) const;
  virtual void getSubVector( const Range1D& rng, RTOpPack::MutableSubVectorT<Scalar>* sub_vec );
  virtual void commitSubVector( RTOpPack::MutableSubVectorT<Scalar>* sub_vec );
  virtual void setSubVector( const RTOpPack::SparseSubVectorT<Scalar>& sub_vec );
  // Multi-vector overrides
  ...
};

template<class Scalar>
void applyOp( const RTOpPack::RTOpT<Scalar> &op, const size_t num_vecs
    ,const Vector<Scalar>* vecs[], const size_t num_targ_vecs ,Vector<Scalar>* targ_vecs[]
    ,RTOpPack::ReductTarget *reduct_obj ,const Index first_ele=1 ,const Index sub_dim=0
    ,const Index global_offset=0 );

template<class Scalar>
void applyOp( const RTOpPack::RTOpT<Scalar> &primary_op, const size_t num_multi_vecs
  ,const MultiVector<Scalar>* multi_vecs[], const size_t num_targ_multi_vecs
  ,MultiVector<Scalar>* targ_multi_vecs[], RTOpPack::ReductTarget* reduct_objs[], const Index primary_first_ele=1
  ,const Index primary_sub_dim=1, const Index primary_global_offset=0, const Index secondary_first_ele=1
  ,const Index secondary_sub_dim=0 ) const;

template<class Scalar>
void applyOp( const RTOpPack::RTOpT<Scalar> &primary_op, const RTOpPack::RTOpT<Scalar> &secondary_op
  ,const size_t num_multi_vecs, const MultiVector<Scalar>* multi_vecs[], const size_t num_targ_multi_vecs
  ,MultiVector<Scalar>* targ_multi_vecs[], RTOpPack::ReductTarget *reduct_obj, const Index primary_first_ele=1
  ,const Index primary_sub_dim=0, const Index primary_global_offset=0, const Index secondary_first_ele=1
  ,const Index secondary_sub_dim=0 ) const;

} // namespace TSFCore
\end{verbatim}}
