//@HEADER
// ************************************************************************
// 
//          Kokkos: Node API and Parallel Node Kernels
//              Copyright (2008) Sandia Corporation
// 
// Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
// the U.S. Government retains certain rights in this software.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// 1. Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//
// 2. Redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// 3. Neither the name of the Corporation nor the names of the
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION "AS IS" AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// Questions? Contact Michael A. Heroux (maherou@sandia.gov) 
// 
// ************************************************************************
//@HEADER

#ifndef __Kokkos_Raw_SparseMatVec_def_hpp
#define __Kokkos_Raw_SparseMatVec_def_hpp

/// \file Kokkos_Raw_SparseMatVec_def.hpp
/// \brief Definitions of "raw" sequential sparse triangular solve routines.
/// \warning This code was generated by the SparseTriSolve.py script.  
///   If you edit this header by hand, your edits will disappear the 
///   next time you run the generator script.

namespace Kokkos {
namespace Raw {

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForfor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForfor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForfor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        Y[i] += A_ij * X[j];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        Y[i] += alpha * A_ij * X[j];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForfor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForfor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForfor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhile (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhile4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhile1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhile2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhile3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhile4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForif (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForif4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForif1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForif2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForif3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForif4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForfor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForfor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[colStrideY] += A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[colStrideY] += A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[colStrideY] += A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForfor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i] += A_ij * X[j];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i] += A_ij * X[j];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i] += A_ij * X[j];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i] += alpha * A_ij * X[j];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i] += alpha * A_ij * X[j];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i] += alpha * A_ij * X[j];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForfor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForfor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForfor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        Y_i[3*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        Y_i[3*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        Y_i[3*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        Y_i[3*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhile (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhile4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhile1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += A_ij * X[j];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhile2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhile3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhile4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForif (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForif4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForif1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += A_ij * X[j];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForif2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForif3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForif4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForfor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForfor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForfor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForfor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForfor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForfor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhile (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhile4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhile1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhile2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhile3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhile4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
      Y_i[3] += A_ij * X_j[3];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
      Y_i[3] += alpha * A_ij * X_j[3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForif (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForif4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForif1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForif2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForif3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForif4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
      Y_i[3] += A_ij * X_j[3];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = val[k];
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
      Y_i[3] += alpha * A_ij * X_j[3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForfor (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForfor4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[1] += A_ij * X_j[1];
            Y_i[2] += A_ij * X_j[2];
            Y_i[3] += A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[1] += A_ij * X_j[1];
            Y_i[2] += A_ij * X_j[2];
            Y_i[3] += A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[1] += A_ij * X_j[1];
            Y_i[2] += A_ij * X_j[2];
            Y_i[3] += A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[1] += alpha * A_ij * X_j[1];
            Y_i[2] += alpha * A_ij * X_j[2];
            Y_i[3] += alpha * A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[1] += alpha * A_ij * X_j[1];
            Y_i[2] += alpha * A_ij * X_j[2];
            Y_i[3] += alpha * A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[1] += alpha * A_ij * X_j[1];
            Y_i[2] += alpha * A_ij * X_j[2];
            Y_i[3] += alpha * A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForfor1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i*rowStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i*rowStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i*rowStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i*rowStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForfor2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForfor3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForfor4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        Y_i[3] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        Y_i[3] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        Y_i[3] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        Y_i[3] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = val[k];
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhile (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhile4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhile1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhile2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhile3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhile4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForif (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForif4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForif1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForif2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForif3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForif4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = val[k];
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForforConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForforConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForforConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        Y[i] += A_ij * X[j];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        Y[i] += alpha * A_ij * X[j];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForforConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForforConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForforConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhileConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhileConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhileConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhileConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhileConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForwhileConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForifConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForifConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForifConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += A_ij * X[j];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i] += alpha * A_ij * X[j];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForifConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForifConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscColMajorForifConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_j[i] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal j = 0; j < numVecs; ++j) {
      RangeScalar* const Y_j = &Y[j*colStrideY];
      for (Ordinal i = 0; i < numRows; ++i) {
        Y_j[i] = beta * Y_j[i];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += A_ij * X_j[0];
      Y_i[colStrideY] += A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i];
      const DomainScalar* const X_j = &X[j];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForforConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForforConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[colStrideY] += A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[colStrideY] += A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[colStrideY] += A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
            Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
            Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForforConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i] += A_ij * X[j];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i] += A_ij * X[j];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i] += A_ij * X[j];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i] += alpha * A_ij * X[j];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i] += alpha * A_ij * X[j];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i] += alpha * A_ij * X[j];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForforConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForforConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForforConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        Y_i[3*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        Y_i[3*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] = STS::zero();
        Y_i[colStrideY] = STS::zero();
        Y_i[2*colStrideY] = STS::zero();
        Y_i[3*colStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i];
        Y_i[0] *= beta;
        Y_i[colStrideY] *= beta;
        Y_i[2*colStrideY] *= beta;
        Y_i[3*colStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i];
          const DomainScalar* const X_j = &X[j];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhileConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhileConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhileConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += A_ij * X[j];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhileConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhileConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForwhileConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForifConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForifConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[colStrideY] += A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[colStrideY] = STS::zero();
            Y_i[2*colStrideY] = STS::zero();
            Y_i[3*colStrideY] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[colStrideY] *= beta;
            Y_i[2*colStrideY] *= beta;
            Y_i[3*colStrideY] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c*colStrideY] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
          Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
          Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c*colStrideY] += alpha * A_ij * X_j[c*colStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForifConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += A_ij * X[j];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i] = STS::zero();
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i] *= beta;
        }
        Y[i] += alpha * A_ij * X[j];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForifConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForifConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrColMajorForifConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal colStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal colStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = beta * Y[c*colStrideY];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c*colStrideY] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += A_ij * X_j[0];
        Y_i[colStrideY] += A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += A_ij * X_j[3*colStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] = STS::zero();
          Y_i[colStrideY] = STS::zero();
          Y_i[2*colStrideY] = STS::zero();
          Y_i[3*colStrideY] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i];
          Y_i[0] *= beta;
          Y_i[colStrideY] *= beta;
          Y_i[2*colStrideY] *= beta;
          Y_i[3*colStrideY] *= beta;
        }
        RangeScalar* const Y_i = &Y[i];
        const DomainScalar* const X_j = &X[j];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[colStrideY] += alpha * A_ij * X_j[colStrideX];
        Y_i[2*colStrideY] += alpha * A_ij * X_j[2*colStrideX];
        Y_i[3*colStrideY] += alpha * A_ij * X_j[3*colStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForforConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForforConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForforConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForforConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForforConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForforConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
  }
  else { // alpha != STS::one()
    for (Ordinal j = 0; j < numCols; ++j) {
      for (Ordinal k = ptr[j]; k < ptr[j+1]; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal i = ind[k];
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhileConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhileConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhileConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhileConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhileConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForwhileConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
      Y_i[3] += A_ij * X_j[3];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      while (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
      Y_i[3] += alpha * A_ij * X_j[3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForifConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      for (Ordinal c = 0; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForifConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += A_ij * X_j[c];
      }
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Ordinal c = 0;
      // Extra +1 in loop bound ensures first 4 iterations get
      // strip-mined, but requires that Ordinal be a signed type.
      for ( ; c < numVecs - 3; c += 4) {
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
      for ( ; c < numVecs; ++c) {
        Y_i[c] += alpha * A_ij * X_j[c];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForifConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForifConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForifConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCscRowMajorForifConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Prescale: Y := beta * Y.
  if (beta == STS::zero()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        // Follow the Sparse BLAS convention for beta == 0. 
        Y_i[j] = STS::zero();
      }
    }
  }
  else if (beta != STS::one()) {
    for (Ordinal i = 0; i < numRows; ++i) {
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      for (Ordinal j = 0; j < numVecs; ++j) {
        Y_i[j] = beta * Y_i[j];
      }
    }
  }
  // Outer for loop preface:
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numCols];
  if (alpha == STS::one()) {
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += A_ij * X_j[0];
      Y_i[1] += A_ij * X_j[1];
      Y_i[2] += A_ij * X_j[2];
      Y_i[3] += A_ij * X_j[3];
    }
  }
  else { // alpha != STS::one()
    Ordinal j = 0;
    for (Ordinal k = 0; k < nnz; ++k) {
      const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
      const Ordinal i = ind[k];
      // NOTE: "if" instead of "while" here is only valid
      // if the matrix contains no empty rows.
      if (k >= ptr[j+1]) {
        ++j;
      }
      RangeScalar* const Y_i = &Y[i*rowStrideY];
      const DomainScalar* const X_j = &X[j*rowStrideX];
      Y_i[0] += alpha * A_ij * X_j[0];
      Y_i[1] += alpha * A_ij * X_j[1];
      Y_i[2] += alpha * A_ij * X_j[2];
      Y_i[3] += alpha * A_ij * X_j[3];
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForforConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForforConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[1] += A_ij * X_j[1];
            Y_i[2] += A_ij * X_j[2];
            Y_i[3] += A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[1] += A_ij * X_j[1];
            Y_i[2] += A_ij * X_j[2];
            Y_i[3] += A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += A_ij * X_j[0];
            Y_i[1] += A_ij * X_j[1];
            Y_i[2] += A_ij * X_j[2];
            Y_i[3] += A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += A_ij * X_j[c];
          }
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] = STS::zero();
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[1] += alpha * A_ij * X_j[1];
            Y_i[2] += alpha * A_ij * X_j[2];
            Y_i[3] += alpha * A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[1] += alpha * A_ij * X_j[1];
            Y_i[2] += alpha * A_ij * X_j[2];
            Y_i[3] += alpha * A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] *= beta;
        }
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] += alpha * A_ij * X_j[0];
            Y_i[1] += alpha * A_ij * X_j[1];
            Y_i[2] += alpha * A_ij * X_j[2];
            Y_i[3] += alpha * A_ij * X_j[3];
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] += alpha * A_ij * X_j[c];
          }
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForforConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i*rowStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i*rowStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        Y[i*rowStrideY] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        Y[i*rowStrideY] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForforConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForforConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForforConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // No preface needed for 'for-for' algorithm variant.
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        Y_i[3] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        Y_i[3] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; set Y(i,:) to 0.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] = STS::zero();
        Y_i[1] = STS::zero();
        Y_i[2] = STS::zero();
        Y_i[3] = STS::zero();
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
      }
    }
    else if (beta == STS::one()) {
      for (Ordinal i = 0; i < numRows; ++i) {
        // We don't have to set Y(i,:) here, since beta == 1.
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
      }
    }
    else { // beta != 0 && beta != 1
      for (Ordinal i = 0; i < numRows; ++i) {
        // We haven't seen row i before; scale Y(i,:) by beta.
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        Y_i[0] *= beta;
        Y_i[1] *= beta;
        Y_i[2] *= beta;
        Y_i[3] *= beta;
        for (Ordinal k = ptr[i]; k < ptr[i+1]; ++k) {
          const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
          const Ordinal j = ind[k];
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          const DomainScalar* const X_j = &X[j*rowStrideX];
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhileConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhileConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhileConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhileConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhileConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForwhileConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        while (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForifConj (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          for (Ordinal c = 0; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        for (Ordinal c = 0; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForifConj4Unrolled (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal numVecs,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += A_ij * X_j[0];
          Y_i[1] += A_ij * X_j[1];
          Y_i[2] += A_ij * X_j[2];
          Y_i[3] += A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += A_ij * X_j[c];
        }
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] = STS::zero();
            Y_i[1] = STS::zero();
            Y_i[2] = STS::zero();
            Y_i[3] = STS::zero();
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] = STS::zero();
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Ordinal c = 0;
          // Extra +1 in loop bound ensures first 4 iterations get
          // strip-mined, but requires that Ordinal be a signed type.
          for ( ; c < numVecs - 3; c += 4) {
            Y_i[0] *= beta;
            Y_i[1] *= beta;
            Y_i[2] *= beta;
            Y_i[3] *= beta;
          }
          for ( ; c < numVecs; ++c) {
            Y_i[c] *= beta;
          }
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Ordinal c = 0;
        // Extra +1 in loop bound ensures first 4 iterations get
        // strip-mined, but requires that Ordinal be a signed type.
        for ( ; c < numVecs - 3; c += 4) {
          Y_i[0] += alpha * A_ij * X_j[0];
          Y_i[1] += alpha * A_ij * X_j[1];
          Y_i[2] += alpha * A_ij * X_j[2];
          Y_i[3] += alpha * A_ij * X_j[3];
        }
        for ( ; c < numVecs; ++c) {
          Y_i[c] += alpha * A_ij * X_j[c];
        }
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForifConj1Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 1;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += A_ij * X[j*rowStrideX];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          Y[i*rowStrideY] = STS::zero();
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          Y[i*rowStrideY] *= beta;
        }
        Y[i*rowStrideY] += alpha * A_ij * X[j*rowStrideX];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForifConj2Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 2;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForifConj3Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 3;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
      }
    }
  }
}

template<class Ordinal,
         class MatrixScalar,
         class DomainScalar,
         class RangeScalar>
void
matVecCsrRowMajorForifConj4Vec (
  const Ordinal numRows,
  const Ordinal numCols,
  const Ordinal,
  const RangeScalar& beta,
  RangeScalar Y[],
  const Ordinal rowStrideY,
  const RangeScalar& alpha,
  const Ordinal ptr[],
  const Ordinal ind[],
  const MatrixScalar val[],
  const DomainScalar X[],
  const Ordinal rowStrideX)
{
  typedef Teuchos::ScalarTraits<RangeScalar> STS;

  const Ordinal numVecs = 4;
  // Outer for loop preface:
  // Algorithm variants 'for-while' and 'for-if' need to set
  // Y(0,:) = 0, but only for the special case of CSR.
  if (beta != STS::zero()) {
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = beta * Y[c];
    }
  }
  else {
    // Follow the Sparse BLAS convention for beta == 0. 
    for (Ordinal c = 0; c < numVecs; ++c) {
      Y[c] = STS::zero();
    }
  }
  if (alpha == STS::zero()) {
    return; // Our work is done!
  }
  const Ordinal nnz = ptr[numRows];
  if (alpha == STS::one()) {
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += A_ij * X_j[0];
        Y_i[1] += A_ij * X_j[1];
        Y_i[2] += A_ij * X_j[2];
        Y_i[3] += A_ij * X_j[3];
      }
    }
  }
  else { // alpha != STS::one()
    if (beta == STS::zero()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; set Y(i,:) to 0.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] = STS::zero();
          Y_i[1] = STS::zero();
          Y_i[2] = STS::zero();
          Y_i[3] = STS::zero();
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else if (beta == STS::one()) {
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We don't have to set Y(i,:) here, since beta == 1.
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
    else { // beta != 0 && beta != 1
      Ordinal i = 0;
      for (Ordinal k = 0; k < nnz; ++k) {
        const MatrixScalar A_ij = Teuchos::ScalarTraits<MatrixScalar>::conjugate (val[k]);
        const Ordinal j = ind[k];
        // NOTE: "if" instead of "while" here is only valid
        // if the matrix contains no empty columns.
        if (k >= ptr[i+1]) {
          ++i;
          // We haven't seen row i before; scale Y(i,:) by beta.
          RangeScalar* const Y_i = &Y[i*rowStrideY];
          Y_i[0] *= beta;
          Y_i[1] *= beta;
          Y_i[2] *= beta;
          Y_i[3] *= beta;
        }
        RangeScalar* const Y_i = &Y[i*rowStrideY];
        const DomainScalar* const X_j = &X[j*rowStrideX];
        Y_i[0] += alpha * A_ij * X_j[0];
        Y_i[1] += alpha * A_ij * X_j[1];
        Y_i[2] += alpha * A_ij * X_j[2];
        Y_i[3] += alpha * A_ij * X_j[3];
      }
    }
  }
}

} // namespace Raw
} // namespace Kokkos

#endif // #ifndef __Kokkos_Raw_SparseMatVec_def_hpp
