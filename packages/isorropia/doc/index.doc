/*! \mainpage Isorropia: Partitioning, Coloring, and Ordering
\htmlonly
\endhtmlonly

\section isorropia_intro Introduction

Isorropia is a package for combinatorial scientific computing, with focus on partitioning (load balancing), but also supports coloring and ordering. Its main purpose is to assist with redistributing objects such as matrices and matrix-graphs in a parallel execution setting, to allow for more efficient computations. Isorropia produces good maps for Epetra matrices/graphs. Isorropia should be called after the matrix/graph is filled, so the sparsity pattern is known.
<br>

      In addition to matrix/graph partitioning, Isorropia has the capability to partition 1, 2 or 3-dimensional real coordinates into balanced spatial regions.  The coordinates are represented as an Epetra_MultiVector.
<br>

Isorropia's coloring capability can also be employed for the purpose of probing structurally symmetric matrices.
<br>

      Isorropia is primarily an interface to the Zoltan toolkit. Zoltan became a Trilinos package in 9.0 and is now a required dependency.
If you wish to use third-party libraries (such as ParMetis or PT-Scotch) with Isorropia (via Zoltan), see the configure options for Zoltan.

<ul>
<li> <a href="#overview">Overview of Isorropia</a>
<li> <a href="#parameters">Parameters</a>
<li> <a href="#partitioning">Partitioning</a>
<li> <a href="#example_programs">Example Programs</a>
<li> <a href="#coloring">Coloring</a>
<li> <a href="#ordering">Ordering</a>
<li> <a href="#ordering">Probing</a>
</ul>

<a name="overview"> </a>
\section isorropia_overview Overview of Isorropia.

Isorropia currently contains algorithms for three separate problems.  In the case
of sparse matrices, these problems can each be viewed as a combinatorial problem based on graphs:
<ul>
<li> Partitioning (load-balancing) and subsequent data redistribution. 
<li> Graph coloring.
<li> Fill-reducing ordering (for sparse direct solvers).
</ul>

Isorropia contains separate classes to solve each of these problems, all of which derive from Isorropia::Operator and Isorropia::Epetra::Operator. Note that an operator in Isorropia is different from an operator in Epetra!

<a name="parameters"> </a>
\section parameters  Isorropia parameters

Isorropia has a fairly small number of parameters, listed below. Note that Isorropia parameters are case insensitive. For more specific control of low-level features, you may set a Zoltan parameter. Isorropia will pass any parameter in the Zoltan sublist to Zoltan.

TODO: List all Isorropia parameters.

<a name="partitioning"> </a>
\section partitioning  Partitioning and Load Balancing

We focus on the partitioning (load balancing), which is the most heavily used feature.
Isorropia's load balancing user interface consists primarily of the Isorropia::Partitioner, Isorropia::Redistributor and Isorropia::CostDescriber classes, as well as the Isorropia::Epetra::createBalancedCopy functions.

The Isorropia::Epetra::createBalancedCopy functions are free-standing functions
(not class members) which simply take an input object (Epetra_CrsGraph,
Epetra_CrsMatrix, etc.) and return a copy which is balanced across
processes (parts). 

In many use cases, such as performing one partitioning
and then using it to redistribute multiple objects, it is more
efficient to use the Isorropia::Partitioner and Isorropia::Redistributor
classes. The general usage model is to:
<ol>
<li> Create a Isorropia::Partitioner instance, providing the objects to be partitioned, and
 optionally weights for those objects.  Weights can be defined with an 
Isorropia::CostDescriber for graphs and hypergraphs, or with an Epetra_MultiVector for
geometric coordinates.
<li> Create a Isorropia::Redistributor object (providing as input a
Isorropia::Partitioner instance)
<li> Use the Isorropia::Redistributor to redistribute one or more objects
 to the new partitioning.
</ol>

Isorropia was designed such that these steps can usually be done in three lines of code. For example, the Partitioner will by default compute the partitioning at construction time.

Isorropia currently supports  partitioning/redistributing of several
Epetra objects, including Epetra_CrsGraph, Epetra_RowMatrix (which includes
Epetra_CrsMatrix and Epetra_VbrMatrix) and Epetra_MultiVector.  
(The Epetra_MultiVector
is interpreted as 1, 2 or 3 dimensional coordinates and is partitioned into balanced spatial regions using Zoltan's geometric partitioning methods.)

Several Isorropia classes and methods accept Teuchos::ParameterList
objects, allowing the user to control certain behavior.
Isorropia parameters can be either lower or upper case.
<ul>
<li>Choice of partitioner<br>
Currently, all partitioning methods are provided by Zoltan. The default option (for sparse matrices) is to minimize communication with the hypergraph model. However, a wide range of partitioners is supported (BLOCK, CYCLIC, RANDOM, GRAPH).
The partitioning method is set by using a Isorropia parameter :
\verbatim
  Teuchos::ParameterList params;
  params.set("partitioning method", "graph"); // Corresponds to LB_METHOD in Zoltan
\endverbatim

<li>Passing parameters through to Zoltan<br>
Isorropia can relay Zoltan parameters directly to Zoltan. Before passing
a Teuchos::ParameterList to Isorropia, create a sublist in it named "Zoltan".
Then, any parameters that should be passed to Zoltan itself, can be stored
in the sublist exactly as they appear in the Zoltan users guide. Example:
\verbatim
  Teuchos::ParameterList params;
  Teuchos::ParameterList& sublist = params.sublist("Zoltan");
  sublist.set("phg_output_level", "5"); 
\endverbatim

Refer to the Zoltan User's guide (available at
<a href=http://www.cs.sandia.gov/zoltan>the Zoltan web site</a>)
for available Zoltan parameters.
In many cases, no parameters are necessary.
Note that Isorropia will override a few default Zoltan settings:
For graphs and matrices, the default method (LB_METHOD) is HYPERGRAPH. The default approach (LB_APPROACH) is PARTITION.  For coordinates the default LB_METHOD is RCB (recursive coordinate bisection).
</ul>

<a name="example_programs"> </a>
\section isorropia_example Example Programs

A number of example programs which demonstrate using Isorropia are
provided in the 'packages/isorropia/example' subdirectory.

\ref matrix_1 demonstrates creating a balanced copy of Epetra_CrsGraph and
Epetra_CrsMatrix objects using Isorropia::Epetra::createBalancedCopy
functions.

\ref part_redist demonstrates repartitioning and redistributing the
contents of an Epetra_LinearProblem object, using the Isorropia::Partitioner
and Isorropia::Redistributor classes. This program does not use
user-specified weights/costs.

Other programs in the example subdirectory demonstrate the use of
weights/costs data to influence the partitioner.
See \ref vert_weights, \ref graphedge_weights and \ref hgedge_weights.

\ref example_rcb demonstrates the use of Isorropia to partition spatial coordinates using Zoltan's Recursive Coordinate Bisection algorithm.

<a name="coloring"> </a>
\section coloring  Coloring 
Isorropia supports vertex coloring of a graph via Zoltan. Both distance-1 and distance-2 coloring is supported. See the Zoltan User's guide (available at
<a href=http://www.cs.sandia.gov/zoltan>the Zoltan web site</a>)
for details. Currently, coloring is limited to structurally symmetric matrices but we expect to support nonsymmetric matrices (e.g. Jacobians) in the future. 


<a name="ordering"> </a>
\section ordering  Ordering 
Isorropia currently supports a subset of the graph (sparse matrix) ordering features in Zoltan. The intended main use is to produce a permutation that can be used as fill-reducing ordering for direct solvers. Currently Zoltan relies on third-party libraries (ParMetis and PT-Scotch) for this.


<a name="probing"> </a>
\section probing  Probing
Isorropia's distance-2 graph vertex capability enables matrix probing, the re-construction (or approximation) of a matrix from matrix-vector products with specially chosen vectors.  These vectors are combinations of columns of the identity which are carefully chosen such that the columns probed by such a vector are structurally orthogonal.  The most common use case of probing is when the matrix is not explicitly stored, but the matrix entries are necessary for some other procedure (e.g. preconditioning).  In certain applications, an exact reconstruction of the matrix is needed.  In others, an approximation based on <em>a priori</em> knowledge of the ``significant'' matrix entries suffices.  Isorropia's probing functionality works in both cases.  See \ref probing for an example of how probing is used.

Currently, Isorropia's probing functionality is limited to structurally symmetric matrices but we expect to support nonsymmetric matrices (e.g. Jacobians) in the future.



*/
