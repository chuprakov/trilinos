/*
 * ExtendedHashtable.hpp
 *
 *  Created on: Aug 29, 2011
 *      Author: wiesner
 */

#ifndef EXTENDEDHASHTABLE_HPP_
#define EXTENDEDHASHTABLE_HPP_

#include <MueLu_Exceptions.hpp>

#include <Teuchos_TabularOutputter.hpp>

namespace MueLu
{
  using std::string;

  namespace UTILS
  {

    class ExtendedHashtable
    {
      public:
        inline ExtendedHashtable() {};

        template<typename Value> inline void Set(const string& ename, const Value& evalue, const FactoryBase* factory);

        template<typename Value> inline Value Get(const string& ename, const FactoryBase* factory);

        inline void Remove(const string& ename, const FactoryBase* factory);

        inline std::string GetType(const string& ename, const FactoryBase* factory);

        inline bool isKey(const string& ename, const FactoryBase* factory);

        std::vector<string> keys();

        std::vector<const MueLu::FactoryBase*> handles(const string ename);

        void Print(std::ostream &out);

      private:
        std::map<const string,std::map<const MueLu::FactoryBase*,Teuchos::any> > dataTable_;

    };

    template<class Value>
    inline void ExtendedHashtable::Set(const string& ename, const Value& evalue, const FactoryBase* factory)
    {
        // if ename does not exist at all
        if (!dataTable_.count(ename) > 0)
        {
          std::map<const MueLu::FactoryBase*,Teuchos::any> newmapData;
          dataTable_[ename] = newmapData; // empty map
        }

        std::map<const MueLu::FactoryBase*,Teuchos::any>& mapData = dataTable_[ename];
        mapData[factory] = evalue;

    }

    template<class Value>
    inline Value ExtendedHashtable::Get(const string& ename, const FactoryBase* factory)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        if(!dataTable_[ename].count(factory) > 0)
        {
          std::stringstream str; str << "key " << ename << " generated by " << factory << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        std::map<const MueLu::FactoryBase*,Teuchos::any> mapData = dataTable_[ename];
        return Teuchos::any_cast<Value>( mapData[factory]);
    }

    inline std::string ExtendedHashtable::GetType(const string& ename, const FactoryBase* factory)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        if(!dataTable_[ename].count(factory) > 0)
        {
          std::stringstream str; str << "key " << ename << " generated by " << factory << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        std::map<const MueLu::FactoryBase*,Teuchos::any> mapData = dataTable_[ename];
        return mapData[factory].typeName();
    }

    //template<class Value>
    inline void ExtendedHashtable::Remove(const string& ename, const FactoryBase* factory)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        if(!dataTable_[ename].count(factory) > 0)
        {
          std::stringstream str; str << "key " << ename << " generated by " << factory << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        if(dataTable_[ename].erase(factory)!=1)
        {
          std::stringstream str; str << "error: could not erase " << ename << "generated gy " << factory;
          throw(Exceptions::RuntimeError(str.str()));
        }

        // check if there exist other instances of 'ename' (generated by other factories than 'factory')
        if(dataTable_.count(ename) == 0)
          dataTable_.erase(ename); // last instance of 'ename' can be removed
    }

    inline bool ExtendedHashtable::isKey(const string& ename, const FactoryBase* factory)
    {
        // check if ename exists
        if (!dataTable_.count(ename) > 0) return false;

        if (dataTable_[ename].count(factory) > 0) return false;

        return true;
    }

    //template<class Value>
    std::vector<string> ExtendedHashtable::keys()
    {
        std::vector<string> v;
        for(map<string,std::map<const MueLu::FactoryBase*,Teuchos::any> >::iterator it = dataTable_.begin(); it!=dataTable_.end(); ++it)
        {
          v.push_back(it->first);
        }
        return v;
    }

    //template<class Value>
    std::vector<const MueLu::FactoryBase*> ExtendedHashtable::handles(const string ename)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }


        std::vector<const MueLu::FactoryBase*> v;
        std::map<const MueLu::FactoryBase*,Teuchos::any> mapData = dataTable_[ename];
        for(map<const MueLu::FactoryBase*,Teuchos::any>::iterator it = mapData.begin(); it!=mapData.end(); ++it)
        {
          v.push_back(it->first);
        }
        return v;
    }

    void ExtendedHashtable::Print(std::ostream &out)
    {
      Teuchos::TabularOutputter outputter(out);
      outputter.pushFieldSpec("name", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT,Teuchos::TabularOutputter::GENERAL,12);
      outputter.pushFieldSpec("gen. factory addr.", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT, Teuchos::TabularOutputter::GENERAL, 18);
      outputter.pushFieldSpec("type", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT, Teuchos::TabularOutputter::GENERAL, 18);
      outputter.outputHeader();

      std::vector<std::string> ekeys = keys();
      for (std::vector<std::string>::iterator it = ekeys.begin(); it != ekeys.end(); it++)
      {
        std::vector<const MueLu::FactoryBase*> ehandles = handles(*it);
        for (std::vector<const MueLu::FactoryBase*>::iterator kt = ehandles.begin(); kt != ehandles.end(); kt++)
        {
          outputter.outputField(*it);
          outputter.outputField(*kt);
          outputter.outputField(GetType(*it,*kt));
          outputter.nextRow();
        }
      }
    }
  }
}


#endif /* EXTENDEDHASHTABLE_HPP_ */
