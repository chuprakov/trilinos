/*
 * ExtendedHashtable.hpp
 *
 *  Created on: Aug 29, 2011
 *      Author: wiesner
 */

#ifndef EXTENDEDHASHTABLE_HPP_
#define EXTENDEDHASHTABLE_HPP_

#include <MueLu_Exceptions.hpp>
#include <MueLu_BaseClass.hpp>
#include <Teuchos_TabularOutputter.hpp>

namespace MueLu
{
  using std::string;

  namespace UTILS
  {
    class ExtendedHashtable : MueLu::BaseClass
    {
      public:
        inline ExtendedHashtable() {};

        template<typename Value> inline void Set(const string& ename, const Value& evalue, RCP<const FactoryBase> factory);

        template<typename Value> inline Value Get(const string& ename, RCP<const FactoryBase> factory);

        inline void Remove(const string& ename, RCP<const FactoryBase> factory);

        inline std::string GetType(const string& ename, RCP<const FactoryBase> factory);

        inline std::string GetType(const string& ename, const FactoryBase* factory);

        inline bool isKey(const string& ename, RCP<const FactoryBase> factory);

        std::vector<string> keys();

        std::vector<const MueLu::FactoryBase*> handles(const string ename);

        void Print(std::ostream &out);

        //! Return a simple one-line description of this object.
        std::string description() const
        {
          return "ExtendedHashtable";
        }

        //! Print the object with some verbosity level to an FancyOStream object.
        void describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel=Teuchos::Describable::verbLevel_default);

      private:
        const MueLu::FactoryBase* resolveFactoryPtr(const string& ename, RCP<const FactoryBase> fact);

      private:
        std::map<const string,std::map<const MueLu::FactoryBase*,Teuchos::any> > dataTable_;

    };

    const MueLu::FactoryBase* ExtendedHashtable::resolveFactoryPtr(const string& ename, RCP<const FactoryBase> fact)
    {
      const FactoryBase* ptrFactory = fact.get(); // this is the memory ptr to the Factory, we are searching for

      // ptrFactory = NULL: no factory at all
      if(ptrFactory==NULL)
        return NULL;

      std::vector<const MueLu::FactoryBase*> ehandles = handles(ename);
      for (std::vector<const MueLu::FactoryBase*>::iterator kt = ehandles.begin(); kt != ehandles.end(); kt++)
      {
        if(*kt==ptrFactory)
        {
          if((*kt)->getID() == fact->getID())
            return *kt;
          else
            throw(Exceptions::RuntimeError("Ooops. Two factories have the same memory address but different ids?"));
        }
      }

      // no corresponding already existing Teuchos::RCP<FactoryBase> found
      // return memory ptr of fact
      return fact.get();
    }

    template<class Value>
    inline void ExtendedHashtable::Set(const string& ename, const Value& evalue, RCP<const FactoryBase> factory)
    {
        // if ename does not exist at all
        if (!dataTable_.count(ename) > 0)
        {
          std::map<const MueLu::FactoryBase*,Teuchos::any> newmapData;
          dataTable_[ename] = newmapData; // empty map
        }

        // resolve factory to a valid factory ptr
        const MueLu::FactoryBase* fact = resolveFactoryPtr(ename,factory);

        std::map<const MueLu::FactoryBase*,Teuchos::any>& mapData = dataTable_[ename];
        mapData[fact] = evalue;

    }

    template<class Value>
    inline Value ExtendedHashtable::Get(const string& ename, RCP<const FactoryBase> factory)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        // resolve factory to a valid factory ptr
        const MueLu::FactoryBase* fact = resolveFactoryPtr(ename,factory);

        if(!dataTable_[ename].count(fact) > 0)
        {
          std::stringstream str; str << "key " << ename << " generated by " << fact << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        std::map<const MueLu::FactoryBase*,Teuchos::any> mapData = dataTable_[ename];
        return Teuchos::any_cast<Value>( mapData[fact]);
    }

    inline std::string ExtendedHashtable::GetType(const string& ename, RCP<const FactoryBase> factory)
    {
        const MueLu::FactoryBase* fact = resolveFactoryPtr(ename,factory);
        return GetType(ename,fact);
    }

    inline std::string ExtendedHashtable::GetType(const string& ename, const FactoryBase* factory)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        if(!dataTable_[ename].count(factory) > 0)
        {
          std::stringstream str; str << "key " << ename << " generated by " << factory << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        std::map<const MueLu::FactoryBase*,Teuchos::any> mapData = dataTable_[ename];
        return mapData[factory].typeName();
    }

    inline void ExtendedHashtable::Remove(const string& ename, RCP<const FactoryBase> factory)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        // resolve factory to a valid factory ptr
        const MueLu::FactoryBase* fact = resolveFactoryPtr(ename,factory);

        if(!dataTable_[ename].count(fact) > 0)
        {
          std::stringstream str; str << "key " << ename << " generated by " << fact << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }

        if(dataTable_[ename].erase(fact)!=1)
        {
          std::stringstream str; str << "error: could not erase " << ename << "generated gy " << fact;
          throw(Exceptions::RuntimeError(str.str()));
        }

        // check if there exist other instances of 'ename' (generated by other factories than 'factory')
        if(dataTable_.count(ename) == 0)
          dataTable_.erase(ename); // last instance of 'ename' can be removed
    }

    inline bool ExtendedHashtable::isKey(const string& ename, RCP<const FactoryBase> factory)
    {
        // check if ename exists
        if (!dataTable_.count(ename) > 0) return false;

        // resolve factory to a valid factory ptr
        const MueLu::FactoryBase* fact = resolveFactoryPtr(ename,factory);

        if (dataTable_[ename].count(fact) > 0) return false;

        return true;
    }

    std::vector<string> ExtendedHashtable::keys()
    {
        std::vector<string> v;
        for(map<string,std::map<const MueLu::FactoryBase*,Teuchos::any> >::iterator it = dataTable_.begin(); it!=dataTable_.end(); ++it)
        {
          v.push_back(it->first);
        }
        return v;
    }

    //template<class Value>
    std::vector<const MueLu::FactoryBase*> ExtendedHashtable::handles(const string ename)
    {
        if(!dataTable_.count(ename) > 0)
        {
          std::stringstream str; str << "key" << ename << " does not exist in Hashtable.";
          throw(Exceptions::RuntimeError(str.str()));
        }


        std::vector<const MueLu::FactoryBase*> v;
        std::map<const MueLu::FactoryBase*,Teuchos::any> mapData = dataTable_[ename];
        for(map<const MueLu::FactoryBase*,Teuchos::any>::iterator it = mapData.begin(); it!=mapData.end(); ++it)
        {
          v.push_back(it->first);
        }
        return v;
    }

    void ExtendedHashtable::Print(std::ostream &out)
    {
      Teuchos::TabularOutputter outputter(out);
      outputter.pushFieldSpec("name", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT,Teuchos::TabularOutputter::GENERAL,12);
      outputter.pushFieldSpec("gen. factory addr.", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT, Teuchos::TabularOutputter::GENERAL, 18);
      outputter.pushFieldSpec("type", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT, Teuchos::TabularOutputter::GENERAL, 18);
      outputter.outputHeader();

      std::vector<std::string> ekeys = keys();
      for (std::vector<std::string>::iterator it = ekeys.begin(); it != ekeys.end(); it++)
      {
        std::vector<const MueLu::FactoryBase*> ehandles = handles(*it);
        for (std::vector<const MueLu::FactoryBase*>::iterator kt = ehandles.begin(); kt != ehandles.end(); kt++)
        {
          outputter.outputField(*it);
          outputter.outputField(*kt);
          outputter.outputField(GetType(*it,*kt));
          outputter.nextRow();
        }
      }
    }

    void ExtendedHashtable::describe(Teuchos::FancyOStream &out, const Teuchos::EVerbosityLevel verbLevel)
    {
      if (verbLevel != Teuchos::VERB_NONE)
      {
        Teuchos::TabularOutputter outputter(out);
        outputter.pushFieldSpec("name", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT,Teuchos::TabularOutputter::GENERAL,12);
        outputter.pushFieldSpec("gen. factory addr.", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT, Teuchos::TabularOutputter::GENERAL, 18);
        outputter.pushFieldSpec("type", Teuchos::TabularOutputter::STRING,Teuchos::TabularOutputter::LEFT, Teuchos::TabularOutputter::GENERAL, 18);
        outputter.outputHeader();

        std::vector<std::string> ekeys = keys();
        for (std::vector<std::string>::iterator it = ekeys.begin(); it != ekeys.end(); it++)
        {
          std::vector<const MueLu::FactoryBase*> ehandles = handles(*it);
          for (std::vector<const MueLu::FactoryBase*>::iterator kt = ehandles.begin(); kt != ehandles.end(); kt++)
          {
            outputter.outputField(*it);
            outputter.outputField(*kt);
            outputter.outputField(GetType(*it,*kt));
            outputter.nextRow();
          }
        }
      }
    }


  }
}


#endif /* EXTENDEDHASHTABLE_HPP_ */
