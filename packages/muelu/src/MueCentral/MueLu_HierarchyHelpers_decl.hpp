#ifndef MUELU_HIERARCHYHELPERS_DECL_HPP
#define MUELU_HIERARCHYHELPERS_DECL_HPP

#include "MueLu_ConfigDefs.hpp"
#include "MueLu_HierarchyHelpers_fwd.hpp"
#include "MueLu_SingleLevelFactoryBase.hpp"
#include "MueLu_TwoLevelFactoryBase.hpp"
#include "MueLu_FactoryManagerBase.hpp"

#include "MueLu_Level_fwd.hpp"

namespace MueLu {

  //! An exception safe way to call the method 'Level::SetFactoryManager()'
  class SetFactoryManager {

  public:

    //@{

    //!
    SetFactoryManager(Level & level, const RCP<const FactoryManagerBase> & factoryManager)
      : level_(level)
    {
      level.SetFactoryManager(factoryManager);
    }

    //! Destructor.
    virtual ~SetFactoryManager() {
      level_.SetFactoryManager(Teuchos::null);
    }

    //@}

  private:
    Level & level_;
    //TODO: const RCP<const FactoryManagerBase> prevFactoryManager_;, save & restore previous factoryManager instead of reset to Teuchos::null.
  };

  // On the first level, 'A' is not generated by a factory (but is user-defined)
  // On other levels, we can use either NoFactory or the real 'A" factory.
  class InternalFactoryManager : public FactoryManagerBase {

  public:

    //!
    InternalFactoryManager(RCP<const FactoryManagerBase> & parentFactoryManager)
      : factoryManager_(parentFactoryManager), noFact_(NoFactory::getRCP())
    { }

    //! Destructor.
    virtual ~InternalFactoryManager() { }

    //! GetFactory
    const RCP<const FactoryBase> & GetFactory(const std::string & varName) const {
      if (varName == "A") return noFact_;
      // if (varName == "P") return noFact_;
      // if (varName == "R") return noFact_;
      // if (varName == "PreSmoother")  return noFact_;
      // if (varName == "PostSmoother") return noFact_;

      return factoryManager_->GetFactory(varName);
    }

    //! Clean
    void Clean() const { factoryManager_->Clean(); }

  private:
    RCP<const FactoryManagerBase> factoryManager_;
    RCP<const FactoryBase> noFact_; //TODO: remove
  };

  template <class Scalar = double, class LocalOrdinal = int, class GlobalOrdinal = LocalOrdinal, class Node = Kokkos::DefaultNode::DefaultNodeType, class LocalMatOps = typename Kokkos::DefaultKernels<void,LocalOrdinal,Node>::SparseOps>
  class TopRAPFactory : public TwoLevelFactoryBase {
#include "MueLu_UseShortNames.hpp"

  public:

    TopRAPFactory(RCP<const FactoryManagerBase> parentFactoryManager);
    TopRAPFactory(RCP<const FactoryManagerBase> parentFactoryManagerFine, RCP<const FactoryManagerBase> parentFactoryManagerCoarse);

    virtual ~TopRAPFactory();

    void DeclareInput(Level & fineLevel, Level & coarseLevel) const;

    void Build(Level & fineLevel, Level & coarseLevel) const;

  private:
    RCP<const FactoryManagerBase> factoryManagerFine_;
    RCP<const FactoryManagerBase> factoryManagerCoarse_;
    RCP<const FactoryBase> PFact_;
    RCP<const FactoryBase> RFact_;
    RCP<const FactoryBase> AcFact_;
  };

  template <class Scalar = double, class LocalOrdinal = int, class GlobalOrdinal = LocalOrdinal, class Node = Kokkos::DefaultNode::DefaultNodeType, class LocalMatOps = typename Kokkos::DefaultKernels<void,LocalOrdinal,Node>::SparseOps>
  class TopSmootherFactory : public SingleLevelFactoryBase { //TODO: inherit from SmootherFactoryBase ?
#include "MueLu_UseShortNames.hpp"

  public:

    TopSmootherFactory(RCP<const FactoryManagerBase> parentFactoryManager, const std::string & varName);

    virtual ~TopSmootherFactory();

    void DeclareInput(Level & level) const;

    void Build(Level & level) const;

  private:
    RCP<const FactoryManagerBase> factoryManager_;
    RCP<const FactoryBase> smootherFact_;
  };

} // namespace MueLu

#define MUELU_HIERARCHYHELPERS_SHORT
#endif // MUELU_HIERARCHYHELPERS_DECL_HPP
