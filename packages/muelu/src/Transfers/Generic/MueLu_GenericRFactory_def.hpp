#ifndef MUELU_GENERICRFACTORY_DEF_HPP
#define MUELU_GENERICRFACTORY_DEF_HPP

#include <Xpetra_Operator.hpp>

#include "MueLu_GenericRFactory_decl.hpp"

#include "MueLu_PFactory.hpp"
#include "MueLu_Monitor.hpp"
#include "MueLu_Memory.hpp"

namespace MueLu {

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  GenericRFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::GenericRFactory(RCP<PFactory> PFact)
    : PFact_(PFact)
  {
    TEUCHOS_TEST_FOR_EXCEPTION(PFact_==Teuchos::null, MueLu::Exceptions::RuntimeError, "GenericRFactory: no valid PFactory provided.");
  }

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  GenericRFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::~GenericRFactory() {}

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  void GenericRFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::DeclareInput(Level &fineLevel, Level &coarseLevel) const {
    bool rmode = PFact_->isRestrictionModeSet();
    PFact_->setRestrictionMode(true);             // set restriction mode

    // force request call for PFact
    // in general, Request is only called once for each factory,
    // since we can reuse data generated by the factory
    // however, here we have to run the code in PFact_.Build again,
    // so we have to request the dependencies of PFact first!
    // The dependencies are (automatically) cleaned up after the second
    // run of PFact_.Build in coarseLevel.Get<RCP<Operator> >("R",PFact_.get())!
    // So we only do request but not release dependencies here!
    coarseLevel.DeclareDependencies(PFact_.get(),true,false);

    coarseLevel.DeclareInput("R", PFact_.get());  // we expect the prolongation operator factory to produce "R" as output
    // call declareInput is called within DeclareInput call
    PFact_->setRestrictionMode(rmode);            // reset restriciton mode flag
  }

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  void GenericRFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::Build(Level & fineLevel, Level & coarseLevel) const {
    return BuildR(fineLevel,coarseLevel);
  }

  template <class Scalar,class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  void GenericRFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::BuildR(Level & fineLevel, Level & coarseLevel) const {

    std::ostringstream buf; buf << coarseLevel.GetLevelID();
    RCP<Teuchos::Time> timer = rcp(new Teuchos::Time("GenericRFactory::BuildR_"+buf.str()));
    timer->start(true);

    Monitor m(*this, "Call prolongator factory for calculating restrictor");

    // BuildR
    bool rmode = PFact_->isRestrictionModeSet();
    PFact_->setRestrictionMode(true);     // switch prolongator factory to restriction mode

    //PFact_->Build(fineLevel, coarseLevel);  // call PFactory::Build explicitely
    RCP<Operator> R = coarseLevel.Get<RCP<Operator> >("R",PFact_.get());

    PFact_->setRestrictionMode(rmode);    // reset restriction mode flag

    coarseLevel.Set("R", R, this);

    timer->stop();
    MemUtils::ReportTimeAndMemory(*timer, *(R->getRowMap()->getComm()));

  } //BuildR

} //namespace MueLu

#define MUELU_GENERICRFACTORY_SHORT
#endif // MUELU_GENERICRFACTORY_DEF_HPP
