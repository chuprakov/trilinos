/*
 * MueLu_SubBlockAggregationFactory_def.hpp
 *
 *  Created on: Mar 28, 2012
 *      Author: wiesner
 */

#ifndef MUELU_SUBBLOCKAGGREGATIONFACTORY_DEF_HPP_
#define MUELU_SUBBLOCKAGGREGATIONFACTORY_DEF_HPP_

#include <Xpetra_Operator.hpp>
#include <Xpetra_BlockedCrsOperator.hpp>

#include "MueLu_SubBlockAggregationFactory_decl.hpp"

#include "MueLu_Level.hpp"
#include "MueLu_Graph.hpp"
#include "MueLu_AmalgamationInfo.hpp"
#include "MueLu_Aggregates.hpp"
#include "MueLu_Monitor.hpp"

namespace MueLu {

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  SubBlockAggregationFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::SubBlockAggregationFactory(RCP<const FactoryBase> aggFact, RCP<const FactoryBase> subBlockAFact)
    : aggFact_(aggFact), subBlockAFact_(subBlockAFact)
  {
  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  void SubBlockAggregationFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::DeclareInput(Level &currentLevel) const {
    //if(currentLevel.IsAvailable("Aggregates",this)) return; //TODO: Why??????

    currentLevel.DeclareInput("Aggregates", aggFact_.get(), this);
    currentLevel.DeclareInput("A", MueLu::NoFactory::get(), this); // global blocked A (for map extractors)
    currentLevel.DeclareInput("A", subBlockAFact_.get(),    this); // sub-block from blocked A

  }

  template <class Scalar, class LocalOrdinal, class GlobalOrdinal, class Node, class LocalMatOps>
  void SubBlockAggregationFactory<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps>::Build(Level &currentLevel) const
  {
    typedef Xpetra::Operator<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> OperatorClass;
    typedef Xpetra::BlockedCrsOperator<Scalar, LocalOrdinal, GlobalOrdinal, Node, LocalMatOps> BlockedCrsOperatorClass;
    typedef Xpetra::MapExtractor<Scalar, LocalOrdinal, GlobalOrdinal, Node> MapExtractorClass;

      FactoryMonitor m(*this, "SubBlock Aggregation", currentLevel);

      // Level Get
      RCP<Aggregates> aggs = currentLevel.Get< RCP<Aggregates> >("Aggregates", aggFact_.get());

      // copy aggregation info (note: the data itself is stored only once. we copy the RCP pointer such that
      // "aggs" and "aggregates" share the same data
      RCP<Aggregates> aggregates = rcp(new Aggregates(*aggs));

      // fetch blocked Operator A from level (we do not have here a special AFact_
      // we expect to be A generated by NoFactory
      RCP<OperatorClass> Op = currentLevel.Get<RCP<OperatorClass> >("A",MueLu::NoFactory::get());
      RCP<BlockedCrsOperatorClass> bOp = Teuchos::rcp_dynamic_cast<BlockedCrsOperatorClass>(Op);

      TEUCHOS_TEST_FOR_EXCEPTION(bOp == Teuchos::null, Exceptions::BadCast, "A cannot casted to a BlockedCrsOperator");

      RCP<const MapExtractorClass> rgMapExtractor = bOp->getRangeMapExtractor();
      RCP<const MapExtractorClass> doMapExtractor = bOp->getDomainMapExtractor();

      // check range maps from range map extractor
      for(size_t i=0; i<rgMapExtractor->NumMaps(); i++) {
        Teuchos::RCP<const Map> rm = rgMapExtractor->getMap(i);
        Teuchos::RCP<const StridedMap> srm = Teuchos::rcp_dynamic_cast<const StridedMap>(rm);
        TEUCHOS_TEST_FOR_EXCEPTION(srm == Teuchos::null, Exceptions::BadCast, "SubBlockAggregationFactory::Build: range map in map extractor has no striding information. error.");
      }

      // check domain maps from domain map extractor
      for(size_t i=0; i<doMapExtractor->NumMaps(); i++) {
        Teuchos::RCP<const Map> dm = doMapExtractor->getMap(i);
        Teuchos::RCP<const StridedMap> sdm = Teuchos::rcp_dynamic_cast<const StridedMap>(dm);
        TEUCHOS_TEST_FOR_EXCEPTION(sdm == Teuchos::null, Exceptions::BadCast, "SubBlockAggregationFactory::Build: domain map in map extractor has no striding information. error.");
      }

      // extract node map from aggregates
      const RCP<const Map> nodeMap = aggregates->GetMap();

      // extract sub block information from blocked operator
      RCP<OperatorClass> A = currentLevel.Get<RCP<OperatorClass> >("A",subBlockAFact_.get());

      // extract target block id of strided map
      //LocalOrdinal targetBlockId = A->getColMap("stridedMaps")->getStridedBlockId();

      // generate amalgamation information (locally)
      Teuchos::RCP<std::map<GlobalOrdinal,std::vector<GlobalOrdinal> > > globalamalblockid2globalrowid = Teuchos::rcp(new std::map<GlobalOrdinal,std::vector<GlobalOrdinal> >);

      // extract information from overlapping column map of A
      for(LocalOrdinal i=0; i<Teuchos::as<LocalOrdinal>(A->getColMap()->getNodeNumElements());i++) {
        // get global DOF id
        GlobalOrdinal gDofId = A->getColMap()->getGlobalElement(i);

        // 1) determine map index within domainMapExtractor gDofId belongs to
        // 2) cast map from domainMapExtractor to strided Map
        // 3) return block size of strided map
        size_t block_size = Teuchos::rcp_dynamic_cast<const StridedMap>(doMapExtractor->getMap(doMapExtractor->getMapIndexForGID(gDofId)))->getFixedBlockSize();

        // translate gDofId to global amal block id (=amalgamation)
        GlobalOrdinal globalblockid = gDofId / Teuchos::as<GlobalOrdinal>(block_size);//GlobalId2GlobalAmalBlockId(gDofId, A, globalgid2globalamalblockid_vector, blockSize);

        // gblockid -> gDofId
        if(globalamalblockid2globalrowid->count(globalblockid) > 0) {
          globalamalblockid2globalrowid->find(globalblockid)->second.push_back(gDofId);
        } else {
          (*globalamalblockid2globalrowid)[globalblockid] = std::vector<GlobalOrdinal>(1,gDofId);
        }
      }

        // debug output
//        typename std::map<GlobalOrdinal,std::vector<GlobalOrdinal> >::iterator git;
//        for (git=globalamalblockid2globalrowid->begin(); git!=globalamalblockid2globalrowid->end(); git++) {
//          std::vector<GlobalOrdinal> growids = git->second;
//          std::cout << A->getRowMap()->getComm()->getRank() << " " << git->first << ": ";
//          for(size_t i=0; i<growids.size(); ++i) {
//            std::cout << growids[i] << " ";
//          }
//          std::cout << std::endl;
//        }

      // set amalgamation information in aggregates structure
      aggregates->GetAmalgamationInfo()->SetAmalgamationParams(globalamalblockid2globalrowid);

      // amalgamation parameters have to be set before!
      aggregates->GenerateImportDofMap();

      // print some debug output
      //aggregates->GetDofMap()->describe(GetOStream(Statistics1),Teuchos::VERB_EXTREME);

      // Level Set
      currentLevel.Set("Aggregates", aggregates, this);

  }

} //namespace MueLu


#endif /* MUELU_SUBBLOCKAGGREGATIONFACTORY_DEF_HPP_ */
