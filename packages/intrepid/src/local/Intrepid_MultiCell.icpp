// @HEADER
// ************************************************************************
//
//                           Intrepid Package
//                 Copyright (2007) Sandia Corporation
//
// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
// license for use of this work by or on behalf of the U.S. Government.
//
// This library is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of the
// License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
// USA
// Questions? Contact Pavel Bochev (pbboche@sandia.gov) or
//                    Denis Ridzal (dridzal@sandia.gov).
//
// ************************************************************************
// @HEADER


/** \file   Intrepid_MultiCell.icpp
\brief  Contains inline function definitions for the Intrepid::MultiCell interface.
\author Created by P. Bochev and D. Ridzal
*/

namespace Intrepid {
  
  //--------------------------------------------------------------------------------------------//
  //                      Accessors operating on a specific MultiCell instance                  //
  //--------------------------------------------------------------------------------------------//
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyNumCells() const {
    return numCells_;
  }

  
  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getMyCellType() const {
    return myCellType_;
  }
  
  
  
  template<class Scalar>
  inline const char* MultiCell<Scalar>::getMyCellName() const {
    return cellNames_[myCellType_];
  }
  
  
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyCellDim() const {
    return (myCellType_ > CELL_CANONICAL_MAX ?
            connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][0].topologicalDim_ :
            connMapCanonical_[myCellType_][0].topologicalDim_);
  }
  
  
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getMyCellNumSubcells(const int subcellDim) const {
    
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( !( (0 <= subcellDim) && (subcellDim <= 3 ) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell dimension"); 
#endif
    // This method is slightly different from the static getCellNumSubcells because NODE is
    // not allowed to be a generating cell type of a MultiCell. The reason is that we do not
    // allow degenerate partitions where one or more cells can have zero measure, i.e., cell
    // partitions which include NODE as a valid cell type. For this reason, it returns "error"
    // value -1 if somehow cellType == NODE
    return(( (myCellType_ == CELL_NODE && subcellDim == 0)
             ? -1
             : (myCellType_ != CELL_NODE && subcellDim > 0) 
             ? ( (myCellType_ > CELL_CANONICAL_MAX) 
                 ? connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][subcellDim-1].numSubcells_ 
                 : connMapCanonical_[myCellType_][subcellDim-1].numSubcells_
                 ) 
             : ( (subcellDim)
                 ? -1 
                 : ( (myCellType_ > CELL_CANONICAL_MAX) 
                     ? connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][0].topologicalDim_-1].numNodesPerSubcell_[0]
                     : connMapCanonical_[myCellType_][connMapCanonical_[myCellType_][0].topologicalDim_-1].numNodesPerSubcell_[0]
                     )
                 )
             )
      );
  }
  
  
  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getMySubcellType(const int subcellDim,const int subcellID) const {
    
#ifdef HAVE_INTREPID_DEBUG
    
    // First check if dimension is within the admissible range
    TEST_FOR_EXCEPTION( !( (0 <= subcellDim) && (subcellDim <=3) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell dimension"); 
    
    // Then check if subcellID does not exceed the number of subcells of this dimension or is < 0
    TEST_FOR_EXCEPTION( !( (0 <= subcellID) && (subcellID < this -> getMyCellNumSubcells(subcellDim) ) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell ID"); 
#endif
    return (!subcellDim ?
            CELL_NODE :
            (getMyCellDim() == subcellDim ? myCellType_ :
             (myCellType_ > CELL_CANONICAL_MAX ?
              connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][subcellDim-1].subcellType_[subcellID] :
              connMapCanonical_[myCellType_][subcellDim-1].subcellType_[subcellID])
             )
            );
  }
  
  
  template<class Scalar>
  inline void MultiCell<Scalar>::getMySubcellVertexIDs(Teuchos::Array<int> & subcellNodeIDs,
                                                     const int subcellDim, 
                                                     const int subcellID) const {
                                                 
#ifdef HAVE_INTREPID_DEBUG
    
    // First check if dimension is within the admissible range
    TEST_FOR_EXCEPTION( !( (0 <= subcellDim) && (subcellDim <=3) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell dimension"); 
    
    // Then check if subcellID does not exceed the number of subcells of this dimension or is < 0
    TEST_FOR_EXCEPTION( !( (0 <= subcellID) && (subcellID < this -> getMyCellNumSubcells(subcellDim) ) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell ID"); 
#endif
    
    // num nodes of the desired subcell
    int num_nodes = getCellNumSubcells(this -> getMySubcellType(subcellDim, subcellID), 0);	
    subcellNodeIDs.resize(num_nodes);
    for (int i=0; i < num_nodes; i++)
      subcellNodeIDs[i] =
        (CELL_NODE == myCellType_ && 0 == subcellDim && 0 == subcellID ?
         0 :
         (0 == subcellDim ?
          subcellID :
          (myCellType_ > CELL_CANONICAL_MAX ?
           connMapCustom_[myCellType_-CELL_CANONICAL_MAX-1][subcellDim-1].nodeList_[subcellID][i] :
           connMapCanonical_[myCellType_][subcellDim-1].nodeList_[subcellID][i]))
         );
  }
 
  
  template<class Scalar>
  inline const Teuchos::Array<short> & MultiCell<Scalar>::getCellEdgeSigns(const int cellID) const{
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( (edgeSigns_.size() == 0),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Undefined edge signs"); 
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return edgeSigns_[cellID];
  }
  
  
  template<class Scalar>
  inline const Teuchos::Array<short> & MultiCell<Scalar>::getCellFaceSigns(const int cellID) const{
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( (faceSigns_.size() == 0),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Undefined face signs");  
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return faceSigns_[cellID];
  }
  
  
  template<class Scalar>
  inline const Teuchos::Array<short> & MultiCell<Scalar>::getCellEdgeTags(const int cellID) const{
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( (edgeTags_.size() == 0),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Undefined edge tags");  
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return edgeTags_[cellID];
  }
  
  
  template<class Scalar>
  inline const Teuchos::Array<short> & MultiCell<Scalar>::getCellFaceTags(const int cellID) const{
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( (faceTags_.size() == 0),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Undefined face tags");  
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return faceTags_[cellID];
  }
  
  
  template<class Scalar>
  inline const Point<Scalar> & MultiCell<Scalar>::getCellVertex(const int cellID, const int vertexID) const {
    
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( !( (0 <= vertexID) && (vertexID < this -> getMyCellNumSubcells(0) ) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid vertex ID");  
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return vertices_[cellID][vertexID];
  }
  
  
  template<class Scalar>
  inline const Teuchos::Array< Point<Scalar> > & MultiCell<Scalar>::getCellVertices(const int cellID) const {
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return vertices_[cellID];
  }
  
  
  template<class Scalar>
  inline const Teuchos::Array< Point<Scalar> > & MultiCell<Scalar>::operator [] (const int cellID) const {
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( !( (0 <= cellID) && (cellID < numCells_) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell ID"); 
#endif
    return vertices_[cellID];
  }
  

//-------------------------------------------------------------------------------------//
//     Static member functions: can be called without prior MultiCell instantiation    //
//-------------------------------------------------------------------------------------//

  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getCellType(const char* cellName) {
    
    // Flag to tell us if the name was found and a temp variable for return argument
    bool nameFound = false;
    ECell cellType = CELL_NODE;;
    
    for (ECell i = CELL_NODE; i < CELL_MAX; i++) {
      if (0 == strcmp(cellName, cellNames_[i])){
        cellType = i;
        nameFound = true;
        break;
      }
    }
    TEST_FOR_EXCEPTION( !nameFound, std::invalid_argument, ">>> ERROR (MultiCell): Invalid cell name");  
    return cellType;
  }
  
  
  template<class Scalar>
  inline const char* MultiCell<Scalar>::getCellName(const ECell cellType) {
    
    // In debug mode check bounds on cellType.
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( ! ( (CELL_NODE <= cellType) && (cellType <= CELL_MAX) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell type");  

#endif
    return cellNames_[cellType];
  }
  
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getCellDim(const ECell cellType) {
    
    // In debug mode check bounds on cellType.
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( ! ( (CELL_NODE <= cellType) && (cellType <= CELL_MAX) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell type");  
    
#endif
    return (cellType > CELL_CANONICAL_MAX ?
            connMapCustom_[cellType-CELL_CANONICAL_MAX-1][0].topologicalDim_ :
            connMapCanonical_[cellType][0].topologicalDim_
            );
  }
  
  /*
  template<class Scalar>
  inline int MultiCell<Scalar>::getCellNumNodes(const ECell cellType) {
    
    // In debug mode check bounds on cellType.
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( ! ( (CELL_NODE <= cellType) && (cellType <= CELL_MAX) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell type");  
    
#endif
    return (CELL_NODE == cellType ? 1 :
            (cellType > CELL_CANONICAL_MAX ?
             connMapCustom_[cellType-CELL_CANONICAL_MAX-1][connMapCustom_[cellType-CELL_CANONICAL_MAX-1][0].topologicalDim_-1].numNodesPerSubcell_[0] :
             connMapCanonical_[cellType][connMapCanonical_[cellType][0].topologicalDim_-1].numNodesPerSubcell_[0]
             )
            );
  }
   */
  
  
  template<class Scalar>
  inline int MultiCell<Scalar>::getCellNumSubcells(const ECell cellType, 
                                               const int subcellDim) {
    // In debug mode check bounds on cellType.
#ifdef HAVE_INTREPID_DEBUG
    TEST_FOR_EXCEPTION( ! ( (CELL_NODE <= cellType) && (cellType <= CELL_MAX) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell type");  
    TEST_FOR_EXCEPTION( !( (0 <= subcellDim) && (subcellDim <=3) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell dimension"); 
#endif
    /*
     This method differs from the non-static getMyCellNumSubcells because the admissible values
     of cellType for this method are not restricted by the consideration that the cellType must
     also be valid for partitioning a domain into cells. As a result, NODE is admissible as an
     argument and the behavior of this method for cellType == NODE and subcellDim == 0 must be specified.
     For this reason it returns 1 - a NODE has 1 0-dimensional subcell.
     */
    return ( ( (cellType == CELL_NODE && subcellDim == 0)
               ? 1
               : (cellType != CELL_NODE && subcellDim > 0) 
                 ? ( (cellType > CELL_CANONICAL_MAX) 
                     ? connMapCustom_[cellType-CELL_CANONICAL_MAX-1][subcellDim-1].numSubcells_ 
                     : connMapCanonical_[cellType][subcellDim-1].numSubcells_
                     ) 
                 : ( (subcellDim)
                     ? -1 
                     : ( (cellType > CELL_CANONICAL_MAX) 
                         ? connMapCustom_[cellType-CELL_CANONICAL_MAX-1][connMapCustom_[cellType-CELL_CANONICAL_MAX-1][0].topologicalDim_-1].numNodesPerSubcell_[0]
                         : connMapCanonical_[cellType][connMapCanonical_[cellType][0].topologicalDim_-1].numNodesPerSubcell_[0]
                         )
                     )
                 )
             );
  }
  
  
  template<class Scalar>
  inline ECell MultiCell<Scalar>::getSubcellType(const ECell cellType, 
                                                 const int subcellDim,
                                                 const int subcellID) {
#ifdef HAVE_INTREPID_DEBUG
    
    // First check bounds on the parent cell type
    TEST_FOR_EXCEPTION( ! ( (CELL_NODE <= cellType) && (cellType <= CELL_MAX) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell type");  
    
    // Then check bounds on the subcell dimension
    TEST_FOR_EXCEPTION( !( (0 <= subcellDim) && (subcellDim <=3) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell dimension"); 
    
    // Finally check if subcellID does not exceed the number of subcells with this dimension, or is <0
    TEST_FOR_EXCEPTION( !( (0 <= subcellID) && (subcellID < MultiCell<Scalar>::getCellNumSubcells(cellType, subcellDim) ) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell ID"); 
#endif
    return (!subcellDim ?
            CELL_NODE :
            (getCellDim(cellType) == subcellDim ?
             cellType :
             (cellType > CELL_CANONICAL_MAX ?
              connMapCustom_[cellType-CELL_CANONICAL_MAX-1][subcellDim-1].subcellType_[subcellID] :
              connMapCanonical_[cellType][subcellDim-1].subcellType_[subcellID]
              )
             )
            );
  }
  
  
  template<class Scalar>
  inline void MultiCell<Scalar>::getSubcellVertexIDs(Teuchos::Array<int> &subcellNodeIDs,
                                                   const ECell cellType, 
                                                   const int subcellDim,
                                                   const int subcellID) {
                                                  
#ifdef HAVE_INTREPID_DEBUG
    
    // First check bounds on the parent cell type
    TEST_FOR_EXCEPTION( ! ( (CELL_NODE <= cellType) && (cellType <= CELL_MAX) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid cell type");  
    
    // Then check if dimension is within the admissible range
    TEST_FOR_EXCEPTION( !( (0 <= subcellDim) && (subcellDim <=3) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell dimension"); 
    
    // Finally check if subcellID does not exceed the number of subcells of this dimension or is < 0
    TEST_FOR_EXCEPTION( !( (0 <= subcellID) && (subcellID < MultiCell<Scalar>::getCellNumSubcells(cellType, subcellDim) ) ),
                        std::invalid_argument,
                        ">>> ERROR (MultiCell): Invalid subcell ID"); 
#endif
                                                 
    int num_nodes = getCellNumSubcells( getSubcellType(cellType, subcellDim, subcellID), 0);
    subcellNodeIDs.resize(num_nodes);
    for (int i=0; i < num_nodes; i++)
      subcellNodeIDs[i] =
        (CELL_NODE == cellType && 0 == subcellDim && 0 == subcellID ?
         0 :
         (0 == subcellDim ?
          subcellID :
          (cellType > CELL_CANONICAL_MAX ?
           connMapCustom_[cellType-CELL_CANONICAL_MAX-1][subcellDim-1].nodeList_[subcellID][i] :
           connMapCanonical_[cellType][subcellDim-1].nodeList_[subcellID][i]
           )
          )
         );  
  }
  
  
  template<class Scalar>
  EStatus MultiCell<Scalar>::getAtlasStatus() const {
    return (atlas_.size() > 0) ? STATUS_DEFINED : STATUS_UNDEFINED;
  }
  
  
  template<class Scalar>
  std::string MultiCell<Scalar>::getAtlasStatusName() const {
    return EStatusToString(this -> getAtlasStatus());
  }
  
  
  
  template<class Scalar>
  const EMapping MultiCell<Scalar>::getCellMappingType(const int cellId) const {
    
    // Atlas needs to be defined before we can ask for mapping types of the cells
    TEST_FOR_EXCEPTION(atlas_.size() == 0,
                       std::invalid_argument,
                       ">>> ERROR (MultiCell): Cannot get cell mapping type without a defined atlas"); 
    
    // The cell chart is in atlas_[cellId], the mapping type is stored in the mappingType_field:
    return atlas_[cellId].mappingType_;
  }
  
  
} // namespace Intrepid
