// @HEADER
// ***********************************************************************
//            copyright
//
// ***********************************************************************
// @HEADER

#ifndef _ZOLTAN2_IDENTIFIERTRAITS
#define _ZOLTAN2_IDENTIFIERTRAITS

#include <algorithm>
#include <vector>
#include <string>
#include <stdint.h>
#include <Zoltan2_config.h>

/*! \file Zoltan2_IdentifierTraits.hpp
  \brief Defines basic traits for application supplied local and global IDs.

*/

namespace Z2{

/*! \struct Z2::IdentifierTraits
  \brief This structure defines the basic traits needed for an identifier.

    If an identifier type is not instantiated here, the caller will get a
    compile time error message indicating that we need to add a new type.

    Design follows Teuchos::OrdinalTraits.
*/

template<typename T>
struct UndefinedIdentifierTraits
{
  //! This function should not compile if there is an attempt to instantiate!
  static inline T notDefined() { return T::Identifer_Type_Needs_To_Be_Added(); }
};
	
template<typename T>
struct IdentifierTraits {

  //! An int generated by the identifier that can be used a key in a hash table.
  static inline int key(const T& )                { return UndefinedIdentifierTraits<T>::notDefined(); }
		
  //! Returns name of this Identifier type
  static inline std::string name()           { return UndefinedIdentifierTraits<T>::notDefined(); }
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS

template<>
struct IdentifierTraits<char> {
  static inline int key(const char &c) { return static_cast<int>(c); }
  static inline std::string name()            {return("char");}
};

template<>
struct IdentifierTraits<short int> {
  static inline int key(const short int &a) { return static_cast<int>(a); }
  static inline std::string name()            {return("short int");}
};

template<>
struct IdentifierTraits<int> {
  static inline int key(const int &a) { return a; }
  static inline std::string name()           {return("int");}
};

template<>
struct IdentifierTraits<unsigned int> {
  static inline int key(const unsigned int &a) { return static_cast<int>(a); }
  static inline std::string name()           {return("unsigned int");}
};

template<>
struct IdentifierTraits<long int> {
  //static inline int key(const long int &a) { return a && Z2_INT_MASK[sizeof(int)];}
  static inline int key(const long int &a) { return static_cast<int>(a);}
  static inline std::string name()           {return("long int");}
};

template<>
struct IdentifierTraits<long unsigned int> {
  static inline int key(const long unsigned int &a) { return static_cast<int>(a); }
  static inline std::string name()           {return("long unsigned int");}
};

template<>
struct IdentifierTraits<long long int> {
  static inline int key(const long long int &a) { return static_cast<int>(a); }
  static inline std::string name()            {return("long long int");}
};

template<>
struct IdentifierTraits<void *> {
  static inline int key(void * const p) {return static_cast<int>(reinterpret_cast<intptr_t>(p)); }
  static inline std::string name()   { return "pointer"; } 
};

template<>
struct IdentifierTraits<std::pair<int, int> > {
  static inline int key(const std::pair<int, int> &pair)  
    { return IdentifierTraits<int>::key(pair.first) + IdentifierTraits<int>::key(pair.second); }
    
  static inline std::string name()     { return("std::pair<int, int>"); }
};

template<>
struct IdentifierTraits<std::vector<int > > {
  static inline int key(const std::vector<int> &v){
    int val=0;
    for (size_t i=0; i < v.size(); i++){
      val += IdentifierTraits<int>::key(v[i]);
    }
    return val;
  }  
  static inline std::string name()  { return( "std::vector<int>");}
};



#endif // DOXYGEN_SHOULD_SKIP_THIS

} // namespace Z2

#endif // _ZOLTAN2_IDENTIFIERTRAITS
