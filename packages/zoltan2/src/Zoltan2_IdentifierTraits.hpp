// @HEADER
// ***********************************************************************
//            copyright
//
// ***********************************************************************
// @HEADER

#ifndef _ZOLTAN2_IDENTIFIERTRAITS
#define _ZOLTAN2_IDENTIFIERTRAITS

#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <stdint.h>
#include <Zoltan2_config.h>

/*! \file Zoltan2_IdentifierTraits.hpp
  \brief Defines basic traits for application supplied local and global IDs.

*/

namespace Z2
{

/*! \struct Z2::IdentifierTraits
  \brief This structure defines the basic traits needed for an identifier.

    If an identifier type is not instantiated here, the caller will get a
    compile time error message indicating that we need to add a new type.

    Design follows Teuchos::OrdinalTraits.
*/

template<typename T>
struct UndefinedIdentifierTraits
{
  //! This function should not compile if there is an attempt to instantiate!
  static inline T notDefined() { return T::Identifer_Type_Needs_To_Be_Added(); }
};
	
template<typename T>
struct IdentifierTraits {

  //! An int generated by the identifier that can be used a key in a hash table.
  static inline std::string key(const T& )                { return UndefinedIdentifierTraits<T>::notDefined(); }
		
  //! Returns name of this Identifier type
  static inline std::string name()           { return UndefinedIdentifierTraits<T>::notDefined(); }
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS

template<>
struct IdentifierTraits<char> {
  static inline std::string key(const char &c) { 
      std::ostringstream os; os << static_cast<int>(c); return os.str();
  }
  static inline std::string name()            {return("char");}
};

template<>
struct IdentifierTraits<short int> {
  static inline std::string key(const short int &a) { 
      std::ostringstream os; os << a; return os.str();
  }
  static inline std::string name()            {return("short int");}
};

template<>
struct IdentifierTraits<int> {
  static inline std::string key(const int &a) {
      std::ostringstream os; os << a; return os.str(); 
  }
  static inline std::string name()           {return("int");}
};

template<>
struct IdentifierTraits<unsigned int> {
  static inline std::string key(const unsigned int &a) {
      std::ostringstream os; os << a; return os.str();
  }
  static inline std::string name()           {return("unsigned int");}
};

template<>
struct IdentifierTraits<long int> {
  static inline std::string key(const long int &a) { 
      std::ostringstream os; os << a; return os.str();
  }
  static inline std::string name()           {return("long int");}
};

template<>
struct IdentifierTraits<long unsigned int> {
  static inline std::string key(const long unsigned int &a) { 
      std::ostringstream os; os << a; return os.str();
  }
  static inline std::string name()           {return("long unsigned int");}
};

template<>
struct IdentifierTraits<long long int> {
  static inline std::string key(const long long int &a) { 
      std::ostringstream os; os << a; return os.str();
  }
  static inline std::string name()            {return("long long int");}
};

template<>
struct IdentifierTraits<void *> {
  static inline std::string key(void * const p) {
      std::ostringstream os; os << p; return os.str();
  }
  static inline std::string name()   { return "pointer"; } 
};

template<>
struct IdentifierTraits<std::pair<int, int> > {
  static inline std::string key(const std::pair<int, int> &pair)  {
      std::ostringstream os; 
      os << IdentifierTraits<int>::key(pair.first) << ":" << IdentifierTraits<int>::key(pair.second);
      return os.str();
  }
    
  static inline std::string name()     { return("std::pair<int, int>"); }
};

#ifdef SERIALIZATION_SUPPORTS_VECTORS
template<>
struct IdentifierTraits<std::vector<int > > {
  static inline std::string key(const std::vector<int> &v){
    std::ostringstream os; 
    for (size_t i=0; i < v.size(); i++){
      os << IdentifierTraits<int>::key(v[i]) << ":";
    }
    return os.str();
  }  
  static inline std::string name()  { return( "std::vector<int>");}
};
#endif



#endif // DOXYGEN_SHOULD_SKIP_THIS

} // namespace Z2

#endif // _ZOLTAN2_IDENTIFIERTRAITS
