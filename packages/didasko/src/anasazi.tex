%@HEADER
% ************************************************************************
% 
%          Trilinos: An Object-Oriented Solver Framework
%              Copyright (2001) Sandia Corporation
% 
% Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
% license for use of this work by or on behalf of the U.S. Government.
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2, or (at your option)
% any later version.
%   
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%   
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
% 
% Questions? Contact Michael A. Heroux (maherou@sandia.gov)
% 
% ************************************************************************
%@HEADER

\chapter{Eigenvalue and Eigenvector Computations with Anasazi}
\label{chap:anasazi}

\ChapterAuthors{Christopher Baker, Heidi Thornquist}

\begin{introchapter}
Two goals motivated the development of the Anasazi eigensolver package: interoperability
and extensibility. The intention of \emph{interoperability} is to ease the use of Anasazi
in a wide range of application environments. To this end, the algorithms written in Anasazi utilize an
abstract interface for operators and vectors, allowing the user to leverage existing
linear algebra libraries. The concept of \emph{extensibility} drives 
development of Anasazi to allow users to make efficient use of Anasazi codes while
simultaneously enabling them to easily develop their own code in the Anasazi framework.
This is encouraged by promoting code modularization and multiple levels of access to
solvers and their data.

In this Chapter, we outline the Anasazi eigensolver framework and motivate the design.
In particular, we present
\begin{itemize}
  \item the Anasazi operator/vector interface (Section~\ref{sec:anasazi:opvec});
  \item the Anasazi eigensolver framework (Section~\ref{sec:anasazi:solver_framework});
  \item a description of Anasazi classes (Section~\ref{sec:anasazi:classes});
  \item the interface to the Epetra linear algebra package (Section~\ref{sec:anasazi:epetra});
  \item an example using Anasazi for the solution of an eigenvalue problem (Section~\ref{sec:anasazi:example}).
\end{itemize}
\end{introchapter}

\section{The Anasazi Operator/Vector Interface}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:opvec}

The Anasazi eigensolver package utilizes abstract interfaces for operators and
multivectors. The goals of this are to leverage existing linear algebra libraries and to
protect previous software investment. Algorithms in Anasazi are developed at a high-level,
where the underlying linear algebra objects are opaque. The choice in linear algebra is
made through templating, and access to the functionality of the underlying objects is
provided via the traits classes Anasazi::MultiVecTraits and Anasazi::OperatorTraits.

These classes define opaque interfaces, specifying the operations that multivector and
operator classes must support in order to be used in Anasazi without exposing low-level
details of the underlying data structures.

The benefit of using a templated traits class over inheritance is that the latter requires
the user to derive multivectors and operators from Anasazi-defined abstract
base classes. The former, however, defines only local requirements: Anasazi-defined traits
classes implemented as user-developed adapters for the chosen multivector and operator
classes.

Anasazi::MultiVecTraits provides routines for the creation of multivectors, as well as
their manipulation. In order to use a specific scalar type and multivector type with
Anasazi, there must exist a template specialization of Anasazi::MultiVecTraits for this
pair of classes. A full list of methods required by Anasazi::MultiVecTraits is given in
Table~\ref{tab:anasazi:mvt}.

\begin{table}
\begin{center}
\begin{tabular}{| p{4cm} || p{8cm} |}
\hline
Method name & Description \\
\hline\hline
Clone           & Creates a new empty multivector containing a specified number of columns.  \\\hline
CloneCopy       & Creates a new multivector with a copy of the contents of an existing multivector (deep copy). \\\hline
CloneView       & Creates a new multivector that shares the selected contents of an existing multivector (shallow copy).  \\\hline
GetVecLength    & Returns the vector length of a multivector.  \\\hline
GetNumberVecs   & Returns the number of vectors in a multivector.  \\\hline
MvTimesMatAddMv & Apply a SerialDenseMatrix $M$ to another multivector $A$, $B \leftarrow \alpha A M + \beta B$.  \\\hline
MvAddMv         & Perform $mv \leftarrow \alpha A + \beta B$.  \\\hline
MvTransMv       & Compute the matrix $C \leftarrow \alpha A^H B$.  \\\hline
MvDot           & Compute the vector $b$ where the components are the individual dot-products of the $i$-th columns of $A$ and $B$, i.e. $b[i] = A[i]^H B[i]$.  \\\hline
MvScale         & Scale the columns of a multivector. \\\hline
MvNorm          & Compute the 2-norm of each individual vector of $A$.  \\\hline
SetBlock        & Copy the vectors in $A$ to a subset of vectors in $B$. \\\hline
MvRandom        & Replace the vectors in $A$ with random vectors.  \\\hline
MvInit          & Replace each element of the vectors in $A$ with $\alpha$.  \\\hline
MvPrint         & Print the multi-vector to an output stream.  \\\hline
\hline
\end{tabular}
\caption{Methods required by MultiVecTraits interface.}
\label{tab:anasazi:mvt}
\end{center}
\end{table}

Just as Anasazi::MultiVecTraits defined the interface required to use a
multivector class with Anasazi, Anasazi::OperatorTraits defines the
interface required to use the combination of a specific operator class with a
specific multivector class. This interface defines a single method:
\begin{verbatim}
OperatorTraits<ScalarType,MV,OP>::Apply(const OP &Op, const MV &x, MV &y)
\end{verbatim}
This method performs the operation $y = Op(x)$, where $Op$ is an operator of type
\verb!OP! and $x$ and $y$ are multivectors of type \verb!MV!. In order to use the
combination of \verb!OP! and \verb!MV!, there must be a specialization of
Anasazi::OperatorTraits for \verb!ScalarType!, \verb!OP! and \verb!MV!. 

Calling methods of MultiVecTraits and OperatorTraits requires that specializations of
these traits classes have been implemented for given template arguments.  
Anasazi provides the following specializations of these traits classes:
\begin{itemize}
  \item Epetra\_MultiVector and Epetra\_Operator (with scalar type double)    
  \item Thyra::MultiVectorBase and Thyra::LinearOpBase (with arbitrary scalar type) \\
        This allows Anasazi to be used with any classes that implement the abstract interfaces provided by the Thyra package.    
  \item Anasazi::MultiVec and Anasazi::Operator (with arbitrary scalar type) \\
        This allows Anasazi to be used with any classes that implement the abstract base
        classes Anasazi::MultiVec and Anasazi::Operator.
\end{itemize}

For user-specified classes that don't match one of the above, specializations of
MultiVecTraits and OperatorTraits will need to be created by the user for use by Anasazi.
Test routines \verb!Anasazi::TestMultiVecTraits()! and
\verb!Anasazi::TestOperatorTraits()! are provided by Anasazi to help in testing
user-developed adapters.


\section{The Anasazi Eigensolver Framework}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:solver_framework}

The goals of flexibility and efficiency can interfere with the goals of simplicity and
ease of use. For example, efficient memory use and low-level data access required in
scientific codes can lead to complicated interfaces and violations of standard
object-oriented development practices.

In Anasazi, this problem is addressed by providing a multi-tiered access strategy for
eigensolver algorithms. Anasazi users have the choice of interfacing at one of two levels:
either working at a high-level with a eigensolver manager or working at a low-level
directly with an eigensolver.

Consider as an example the block Davidson iteration. The essence of this iteration can be
distilled into the following algorithm:
\begin{enumerate}
  \item apply preconditioner $N$ to the current residuals: $H = N R$
  \item use $H$ to expand current basis $V$
  \item use new $V$ to compute a projected eigenproblem
  \item solve the projected eigenproblem and form the Ritz vectors $X$ and Ritz values
    $\Theta$ 
  \item compute the new residuals $R$
\end{enumerate}

In implementing a block Davidson method, this iteration repeats until the basis $V$ is full
(in which case it is time to restart) or some stopping criterion has been satisfied. Many
valid stopping criteria exist, as well as many different methods for restarting the basis.
Both of these, however, are distinct from the essential iteration as described above. A
user wanting to perform block Davidson iterations could ask the solver to perform these
iterations until a user-specified stopping criterion was satisfied or the basis was full,
at which time the user would perform a restart. This allows the user complete control over
the stopping criteria and the restarting mechanism, and leaves the eigensolver responsible
for a relatively simple bit of state and behavior.

This is the way that Anasazi has been designed. The eigensolvers (encapsulating an
iteration and the associated state) are derived classes of the abstract base class
Anasazi::Eigensolver. The goals of this class are three-fold:
\begin{itemize}
  \item to define an interface used for checking the status of a solver by a status test;
  \item to contain the essential iteration associated with a particular eigensolver iteration;
  \item to contain the state associated with that iteration.
\end{itemize}

The status tests, assembled to describe a specific stopping criterion and queried by the eigensolver
during the iteration, are represented as subclasses of Anasazi::StatusTest. The
communication between status test and eigensolver occurs
inside of the \verb!iterate()! method provided by each Anasazi::Eigensolver. This code
generally takes the form:
\begin{verbatim}
SomeEigensolver::iterate() {
  while ( statustest.checkStatus(this) != Passed ) {
    //
    // perform eigensolver iterations
    //
  }
  return;  // return back to caller
}
\end{verbatim}

Each Anasazi::StatusTest provides a method, \verb!checkStatus()!, which through queries to
the methods provided by Anasazi::Eigensolver, determines whether the solver meets the
criteria defined by that particular status test. After a solver returns from
\verb!iterate()!, the caller has the option of accessing the state associated with the
solver and re-initializing the solver with a new state.

While this method of interfacing with the solver is powerful, it can be tedious.
This method requires that user construct a number of support classes, in addition to
managing call to \verb!Eigensolver::iterate()!.
The Anasazi::SolverManager class was developed to
address this complaint. A solver manager is a class that wraps around an eigensolver,
providing additional functionality while also handling lower-level interaction with the
eigensolver that a user may not wish to handle. Solver managers are intended to be 
easy to use, while still providing the features and flexibility needed to solve real-world
eigenvalue problems. For example, the Anasazi::BlockDavidsonSolMgr takes only two
arguments in its constructor: an Anasazi::Eigenproblem specifying the eigenvalue problem
to be solved and a Teuchos::ParameterList of options specific to this solver manager. The
solver manager instantiates an eigensolver, along with the status tests and other support
classes needed by the eigensolver. To solve the eigenvalue problem, the user simply calls
the \verb!solve()! method of the solver manager. The solver manager performs repeated
calls to the eigensolver \verb!iterate()! method, performs restarts and locking, and
places the final solution into the eigenproblem.

Users therefore have a number of options for performing eigenvalue computations with Anasazi:
\begin{itemize}
  \item use an existing solver manager;\\
        In this case, the user is limited to the functionality provided by the current eigensolvers.
  \item develop a new solver manager around an existing eigensolver;\\
        The user can extend the functionality provided by the eigensolver, specifying 
        custom configurations for status tests, orthogonalization, restarting, locking,
        etc.
  \item develop a new eigensolver/solver manager;\\
        The user can write an eigensolver for an iteration that is not represented in
        Anasazi. The user still has the benefit of the support classes provided by 
        Anasazi, and the knowledge that the new solver/solver manager can be easily
        used by anyone already familiar with Anasazi.
\end{itemize}


\section{Anasazi Classes}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:classes}

Anasazi is designed with extensibility in mind, so that users can augment the package with
any special functionality that they need. However, the released version of Anasazi
provides all functionality necessary for solving a wide variety of problems. This section
list and briefly describes the current classes found in Anasazi.

The solution of an eigenvalue problem requires a minimum subset of Anasazi classes. The
following is a list of classes that any Anasazi user must be familiar with to use the
package.

\begin{remark}
Anasazi makes extensive use of the Teuchos utility classes, especially
Teuchos::RCP (Section~\ref{sec:teuchos:RCP}) and
Teuchos::ParameterList (Section~\ref{sec:teuchos:ParameterList}). Users
are encouraged to become familiar with these classes and their correct
usage.
\end{remark}

\subsection{Anasazi::Eigenproblem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:eigenproblem}

Anasazi::Eigenproblem is a container for the components of an eigenvalue problem, as well
as the solutions. By requiring eigenproblems to derive from Anasazi::Eigenproblem, Anasazi
defines a minimum interface that can be expected of all eigenvalue problems by the classes
that will work with the problems (e.g., eigensolvers and status testers).

Both the eigenproblem and the eigensolver in Anasazi are templated 
on the scalar type, the multivector type and the operator type. Before
declaring an eigenproblem, users must choose classes to represent these
entities. Having done so, they can begin to specify the parameters of the
eigenvalue problem. The Anasazi::Eigenproblem defines \textbf{set} methods for
the parameters of the eigenproblem. These methods are:
\begin{itemize}
\item \verb!setOperator! - set the operator for which the eigenvalues will be computed
\item \verb!setA! - set the $A$ operator for the eigenvalue problem $A x = M x \lambda$
\item \verb!setM! - set the $M$ operator for the eigenvalue problem $A x = M x \lambda$
\item \verb!setPrec! - set the preconditioner for the eigenvalue problem
\item \verb!setInitVec! - set the initial iterate
\item \verb!setAuxVecs! - set the auxiliary vectors, a subspace used to constrain the
  search space for the solution
\item \verb!setNEV! - set the number of eigenvalues to be computed
\item \verb!setHermitian! - specify whether the problem is Hermitian
\end{itemize}
In addition to these \textbf{set} methods, Anasazi::Eigenproblem defines
a method \verb!setProblem()! that gives the class the opportunity to perform
any initialization that may be necessary before the problem is handed off to an
eigensolver, in addition to verifying that the problem has been adequately defined. 

For each of the \textbf{set} methods listed above, there is a corresponding
\textbf{get} function. These are the functions used by eigensolvers and solver managers to get
the necessary information from the eigenvalue problem. In addition, there are
two methods for storing and retrieving the results of the eigenvalue computation:
\begin{verbatim}
const Eigensolution & getSolution();
void                  setSolution(const Eigensolution & sol);
\end{verbatim}
The Anasazi::Eigensolution structure is described in
Section~\ref{sec:anasazi:eigensolution}.

Anasazi provides users with a basic implementation of
Anasazi::Eigenproblem, called Anasazi::BasicEigenproblem
(Section~\ref{sec:anasazi:example}).
This formulation provides all the functionality
necessary to describe both generalized and standard linear eigenvalue problems.


\subsection{Anasazi::Eigensolution}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:eigensolution}

The Anasazi::Eigensolution structure was developed in order to facilitate setting
and retrieving of solution data. The class contains the following information:
\begin{itemize}
  \item \verb!Teuchos::RCP< MV > Evecs! \\ 
   The computed eigenvectors.
 \item \verb!Teuchos::RCP< MV > Espace! \\ 
   An orthonormal basis for the computed eigenspace.
 \item \verb!std::vector< Value< ScalarType > > Evals! \\ 
   The computed eigenvalues.
 \item \verb!std::vector< int > index! \\ 
   An index into \verb!Evecs! to enable compressed storage of eigenvectors for real, non-Hermitian problems.
 \item \verb!int numVecs! \\
   The number of computed eigenpairs.
\end{itemize}

All Anasazi solver managers place the results of the computation in the
Anasazi::Eigen\-problem class using an Anasazi::Eigensolution structure. The number of
eigensolutions computed is given by field \verb!numVecs!. The eigenvalues are
always stored as two real values, even when templated on a complex data type or when the eigenvalues
are real. Similarly, the eigenspace can always be represented by a multivector of width
\verb!numVecs!, even for non-symmetric eigenproblems over the real field. The storage
scheme for eigenvectors requires more finesse.

When solving real symmetric eigenproblems, the eigenvectors can always be chosen to be
real, and therefore can be stored in a single column of a real multivector. When solving
eigenproblems over a complex field, whether Hermitian or non-Hermitian, the eigenvectors
may be complex, but the multivector is defined over the complex field, so that this poses
no problem. However, real non-symmetric problems can have complex eigenvectors, which
prohibits a one-for-one storage scheme using a real multivector.  Fortunately, the
eigenvectors in this scenario occur as complex conjugate pairs, so the pair can be stored
in two real vectors. This permits a compressed storage scheme, which uses an index vector
stored in the Eigensolution, allowing conjugate pair eigenvectors to be easily retrieved
from \verb!Evecs!. 

The integers in Anasazi::Eigensolution::index take one of three values: $\{0, +1, -1\}$.
These values allow the eigenvectors to be retrieved as follows:
\begin{itemize}
  \item $index[i]=0$: the $i$-th eigenvector is stored uncompressed in column $i$ of
    \verb!Evecs!.
  \item $index[i]=+1$: the $i$-th eigenvector is stored compressed, with the real
    component in column $i$ of \verb!Evecs! and the \emph{positive} complex component
    stored in column $i+1$ of \verb!Evecs!
  \item $index[i]=-1$: the $i$-th eigenvector is stored compressed, with the real
    component in column $i-1$ of \verb!Evecs! and the \emph{negative} complex component
    stored in column $i$ of \verb!Evecs!
\end{itemize}
Because this storage scheme is only required for non-symmetric problems over the real
field, all other eigenproblems will result in an index vector composed entirely of zeroes.
For the real non-symmetric case, the $+1$ index will always immediately precede the
corresponding $-1$ index.

\begin{remark}
  Solver managers all put the computed eigensolution into the eigenproblem class before
  returning from \verb!solve()!. Eigensolvers do not; a user working directly with an
  eigensolver will need to recover the solution directly from the eigensolver state.
\end{remark}

\subsection{Anasazi::Eigensolver}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:eigensolver}

The Anasazi::Eigensolver class defines the basic interface that must be
met by any eigensolver class in Anasazi. The specific eigensolvers are
implemented as derived classes of Anasazi::Eigensolver.
Table~\ref{tab:anasazi:solvers} lists the eigensolver currently implemented in
Anasazi.

\begin{table}[htp]
\begin{center}
\begin{tabular}{| p{4cm} p{10cm} |}
\hline
Solver & Description \\
\hline
{\tt BlockDavidson}    & A block Davidson solver for Hermitian
                         eigenvalue problems.\\
{\tt BlockKrylovSchur} & A block Krylov Schur solver for Hermitian or
                         non-Hermitian eigenvalue problems.\\
{\tt LOBPCG} & The locally optimal block preconditioned conjugate gradient
method for Hermitian eigenproblems.\\
\hline
\end{tabular}
\caption{Eigensolvers currently implemented in Anasazi.}
\label{tab:anasazi:solvers}
\end{center}
\end{table}

Each eigensolver provides two significant types of methods: status methods and
solver-specific state methods. The status methods are defined by the Anasazi::Eigensolver
abstract base class and represent the information that a generic status test can request
from any eigensolver. A list of these methods is given in
Table~\ref{tab:anasazi:genstatusmethods}.

\begin{table}[htp]
\begin{center}
\begin{tabular}{| p{4cm} p{10cm} |}
\hline
Method & Description \\
\hline
{\tt getNumIters}       & Get the current number of iterations. \\
{\tt getRitzValues}     & Get the most recent Ritz values. \\
{\tt getRitzVectors}    & Get the most recent Ritz vectors. \\
{\tt getRitzIndex}      & Get the Ritz index needed for indexing compressed Ritz vectors. \\
{\tt getResNorms}       & Get the most recent residual norms, with respect to the OrthoManager. \\
{\tt getRes2Norms}      & Get the most recent residual 2-norms. \\
{\tt getRitzRes2Norms}  & Get the most recent Ritz residual 2-norms. \\
{\tt getCurSubspaceDim} & Get the current subspace dimension. \\
{\tt getMaxSubspaceDim} & Get the maximum subspace dimension. \\
{\tt getBlockSize}      & Get the block size. \\
\hline
\end{tabular}
\caption{A list of generic status methods provided by Anasazi::Eigensolver.}
\label{tab:anasazi:genstatusmethods}
\end{center}
\end{table}

The class Anasazi::Eigensolver, like Anasazi::Eigenproblem, is templated on the scalar
type, multivector type and operator type. The options for the eigensolver are passed
through the constructor, defined by Anasazi::Eigensolver to have the following form:
\begin{verbatim}
Eigensolver( 
   const Teuchos::RCP< Eigenproblem<ST,MV,OP> > &problem, 
   const Teuchos::RCP< SortManager<ST,MV,OP>  > &sorter,
   const Teuchos::RCP< OutputManager<ST>      > &printer,
   const Teuchos::RCP< StatusTest<ST,MV,OP>   > &tester,
   const Teuchos::RCP< OrthoManager<ST,OP>    > &ortho,
   ParameterList                                        &params  
 );
\end{verbatim}

These classes are used as follows:
\begin{itemize}
  \item \verb!problem! - the eigenproblem to be solved; the solver will
    get the problem operators from here.
  \item \verb!sorter! - the sort manager selects the significant eigenvalues; see
    Section~\ref{sec:anasazi:sorter}.
  \item \verb!printer! - the output manager dictates verbosity level in addition to 
    processing output streams; see Section~\ref{sec:anasazi:printer}.
  \item \verb!tester! - the status tester dictates when the solver should quit
    \verb!iterate()! and return to the caller; see Section~\ref{sec:anasazi:tester}.
  \item \verb!ortho! - the orthogonalization manager defines the inner product and other
    concepts related to 
    orthogonality, in addition to performing these computations for the solver; see
    Section~\ref{sec:anasazi:ortho}.
  \item \verb!params! - the parameter list specifies eigensolver-specific options; see the
    documentation for a list of options support by individual solvers.
\end{itemize}

In addition to specifying an iteration, an eigensolver also specifies a concept of state,
i.e. the current data associated with the iteration. After declaring an Eigensolver
object, the state of the solver is in an uninitialized state. For most solver, to be
initialized mean to be in a valid state, containing all of the information necessary for
performing eigensolver iterations. Anasazi::Eigensolver provides two methods concerning
initialization: \verb!isInitialized()! indicates whether the solver is initialized or not,
and \verb!initialize()! (with no arguments) instructs the solver to initialize itself
using random data or the initial vectors stored in the eigenvalue problem.

To ensure that solvers can be used as efficiently as possible, 
the user needs access to the state of the
solver. To this end, each eigensolver provides low-level methods for getting and setting the
state of the solver:
\begin{itemize}
  \item \verb!getState()! - returns a solver-specific structure with read-only pointers to
    the current state of the solver.
  \item \verb!initialize(...)! - accepts a solver-specific structure enabling the user to
    initialize the solver with a particular state.
\end{itemize}

The combination of these two methods, along with the flexibility provided by status tests,
allows the user almost total control over eigensolver iterations.


\subsection{Anasazi::SolverManager}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:solvermanager}

Using Anasazi by interfacing directly with eigensolvers is extremely powerful, but can be
tedious. Solver managers provide a way for users to encapsulate specific solving
strategies inside of an easy-to-use class. Novice users may prefer to use existing solver
managers, while advanced user may prefer to write custom solver managers.

Anasazi::SolverManager defines only two methods: a constructor accepting an
Anasazi::\-Eigenproblem and a parameter list of solver manager-specific options; and a
\verb!solve()! method, taking no arguments and returning 
either Anasazi::Converged or Anasazi::Unconverged.
Consider the following example code:
\begin{verbatim}
// create an eigenproblem
Teuchos::RCP< Anasazi::Eigenproblem<ScalarType,MV,OP> > problem = ...;
// create a parameter list
Teuchos::ParameterList params;
params.set(...);
// create a solver manager
Anasazi::BlockDavidsonSolMgr<ScalarType,MV,OP> solman(problem,params);
// solve the eigenvalue problem
Anasazi::ReturnType ret = solman.solve();
// get the solution from the problem
Anasazi::Eigensolution sol = problem->getSolution();
\end{verbatim}

\begin{remark}
  Errors in Anasazi are communicated via exceptions. This is outside the scope of this
  tutorial; see the Anasazi documentation for more information.
\end{remark}

As has been stated before, the goal of the solver manager is to create an eigensolver
object, along with the support objects needed by the eigensolver. Another purpose of many
solver managers is to manage and initiate the repeated calls to the underlying solver's
\verb!iterate()! method. For solvers that build a Krylov subspace to some maximum
dimension (e.g., BlockKrylovSchur and BlockDavidson), the solver manager will also assume
the task of restarting the solver when the subspace is full. This is something for which
multiple approaches are possible. Also, there may be substantial flexibility in creating
the support classes (e.g., sort manager, status tests) for the solver. An aggressive
solver manager could even go so far as to construct a preconditioner for the eigenvalue
problem. 

These examples are meant to illustrate the flexibility that specific solver managers may
have in implementing the \verb!solve()! routine. Some of these options might best be
incorporated into a single solver manager, which takes orders from the user via the
parameter list given in the constructor. Some of these options may better be contained in
multiple solver managers, for the sake of code simplicity. It is even possible to write
solver managers that contain other solvers managers; motivation for something like this
would be to select the optimal solver manager at runtime based on some expert knowledge,
or to create a hybrid method which uses the output from one solver manager to
initialize another one.

\subsection{Anasazi::StatusTest}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:tester}

By this point in the tutorial, the purpose of the Anasazi::StatusTest should be clear: to
give the user or solver manager flexibility in stopping the eigensolver iterations in
order to interact directly with the solver.

Many reasons exist for why a user would want to stop the solver from iterating:
\begin{itemize}
  \item some convergence criterion has been satisfied and it is time to quit;
  \item some part of the current solution has reached a sufficient accuracy to removed
    from the iteration (``locking'');
  \item the solver has performed a sufficient or excessive number of iterations.
\end{itemize}
These are just some commonly seen reasons for ceasing the iteration, and each of these can
be so varied in implementation/parametrization as to require some abstract mechanism
controlling the iteration.

The following is a list of Anasazi-provided status tests:
\begin{itemize}
  \item Anasazi::StatusTestCombo - this status test allows for the boolean combination of
    other status tests, creating near unlimited potential for complex status tests.
  \item Anasazi::StatusTestOutput - this status test acts as a wrapper around another
    status test, allowing for printing of status information on a call to
    \verb!checkStatus()!
  \item Anasazi::StatusTestMaxIters - this status test monitors the number of iterations
    performed by the solver; it can be used to halt the solver at some maximum number of iterations
    or even to require some minimum number of iterations.
  \item Anasazi::StatusTestResNorm - this status test monitors the residual norms of the
    current iterate.
  \item Anasazi::StatusTestOrderedResNorm - this status test also monitors the residual
    norms of the current iterate, but only considers the residuals associated with the
    most significant part of the current iterate.
\end{itemize}

\subsection{Anasazi::SortManager}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:sorter}

The purpose of a sort manager is to separate the eigensolver classes from the
sorting functionality required by those classes. This satisfies the flexibility
principle sought by Anasazi, by giving users the opportunity to perform the
sorting in whatever manner is deemed to be most appropriate. Anasazi defines an
abstract class Anasazi::SortManager with two methods, one for sorting real
values and one for sorting complex values:
\begin{verbatim}
ReturnType sort (..., std::vector<MagnitudeType> &evals, 
                      std::vector<int> *perm) 
ReturnType sort (..., std::vector<MagnitudeType> &r_evals, 
                      std::vector<MagnitudeType> &i_evals, 
                      std::vector<int> *perm)
\end{verbatim}
Each of these sort routines will sort the eigenvalues according to some
implementation and optionally return the permutation vector as well (useful for
sorting associated vectors). 

Anasazi provides a derived class Anasazi::BasicSort.  This class provides basic sorting
functionality, described in Table~\ref{tab:anasazi:sm}.

\begin{table}
\begin{center}
\begin{tabular}{| p{2cm} l |}
\hline
Option & Action \\
\hline
{\tt SM} & Sort eigenvalues in increasing order of magnitude \\
{\tt SR} & Sort eigenvalues in increasing order of real part \\
{\tt SI} & Sort eigenvalues in increasing order of imaginary part \\
{\tt LM} & Sort eigenvalues in decreasing order of magnitude \\
{\tt LR} & Sort eigenvalues in decreasing order of real part \\
{\tt LI} & Sort eigenvalues in decreasing order of imaginary part \\
\hline
\end{tabular}
\caption{Options for Anasazi::BasicSort.}
\label{tab:anasazi:sm}
\end{center}
\end{table}


\subsection{Anasazi::OrthoManager}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:ortho}

Orthogonalization and orthonormalization are commonly performed computations in iterative
eigensolvers; in fact, for some eigensolvers, they represent the dominant cost.  Different
scenarios may require different approaches (e.g., Euclidean inner product versus $M$ inner
product, orthogonal projections versus oblique projections).  Combined with the plethora
of available methods for performing these computations, Anasazi has left as much leeway to
the users as possible.

Orthogonalization of multivectors in Anasazi is performed by derived classes of
the abstract class Anasazi::OrthoManager. This class provides five methods:
\begin{itemize}
  \item \verb!innerProd(X,Y,Z)! - performs the inner product defined by the manager.
  \item \verb!norm(X)! - computes the norm induced by \verb!innerProd()!.
  \item \verb!project(X,C,Q)! - given an orthonormal basis $Q$, projects $X$ onto to the space perpindicular to
    $colspan(Q)$, optionally returning the coefficients of $X$ in $Q$.
  \item \verb!normalize(X,B)! - returns an orthonormal basis for $colspan(X)$, optionally
    returning the coefficients of $X$ in the computed basis.
  \item \verb!projectAndNormalize(X,C,B,Q)! - computes an orthonormal basis for subspace
    \newline
    $colspan(X) - colspan(Q)$, optionally returning the coefficients of
    $X$ in $Q$ and the new basis.
\end{itemize}

It should be noted that a call to \verb!projectAndNormalize()! is not necessarily
equivalent to a call to \verb!project()! followed by \verb!normalize()!. This follows from
the fact that, for some orthogonalization managers, a call to \verb!normalize()! may
augment the column span of a rank-deficient multivector in order to create an orthonormal
basis with the same number of columns as the input multivector. In this case, the code
\begin{verbatim}
orthoman.project(X,C,Q);
orthoman.normalize(X,B);
\end{verbatim}
\noindent could result in an orthonormal basis $X$ that is not orthogonal to the basis in $Q$.

Anasazi provides two orthogonalization managers:
\begin{itemize}
  \item Anasazi::BasicOrthoManager - performs orthogonalization using multiple steps of
    classical Gram-Schmidt.
  \item Anasazi::SVQBOrthoManager - performs orthogonalization using the SVQB
    orthogonalization technique described by Stathapoulos and Wu.
\end{itemize}

More information on these orthogonalization managers is available in the Anasazi
documentation.

\subsection{Anasazi::OutputManager}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:printer}

The output manager in Anasazi exists to provide
flexibility with regard to the verbosity of the eigensolver. Each output manager has
two primary concerns: what output is printed and where the output is printed to.
When working with the output manager, output is classified into one of the 
message types from Table~\ref{tab:anasazi:om}.

\begin{table}
\begin{center}
  \begin{tabular}{| p{4cm} p{8cm} |}
\hline
Message type & Description \\
\hline
{\tt Errors           } & Errors (always printed)  \\
{\tt Warnings         } & Warning messages   \\
{\tt IterationDetails } & Approximate eigenvalues, errors   \\
{\tt OrthoDetails     } & Orthogonalization/orthonormalization checking \\
{\tt FinalSummary     } & Final computational summary (usually from SolverManager::solve())  \\
{\tt TimingDetails    } & Timing details  \\
{\tt StatusTestDetails} & Status test details   \\
{\tt Debug            } & Debugging information \\
\hline
\end{tabular}
\caption{Message types used by Anasazi::OutputManager.}
\label{tab:anasazi:om}
\end{center}
\end{table}

Output manager in Anasazi are subclasses of the abstract base class
Anasazi::Output\-Manager. This class provides the following output-related methods:
\begin{itemize}
  \item {\tt bool isVerbosity (MsgType type)} - 
  Find out whether we need to print out information for this message type.
\item {\tt void  print (MsgType type, const string output)} - 
  Send output to the output manager.
\item {\tt ostream \& stream (MsgType type)} - 
  Create a stream for outputting to.
\end{itemize}

The output manager is meant to ease some of the difficulty associated with I/O in a
distributed programming environment. For example, consider some debugging output requiring
optional computation. For reasons of efficiency, we may want to perform the computation
only if debugging is requested; i.e., \verb!isVerbosity(Anasazi::Debug) == true!. However,
while we need all nodes to enter the code block to perform the computation, we probably
want only one of them to print the output. Furthermore, the user may want different types
of output treated in a different manner. The abstraction of the printing
mechanism allows both of these goals to be met.

Anasazi provides a single output manager, Anasazi::BasicOutputManager. This class accepts
an output stream from the user. The output corresponding to the verbosity level of the
manager is sent to this stream only on the master node; the output for other nodes is
neglected.

\section{Using the Anasazi adapter to Epetra}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:epetra}

The Epetra package provides the underlying linear algebra foundation for many
Trilinos solvers.  By using the Anasazi adapter to Epetra, users not only
avoid the trouble of designing their own multivector and operator classes, but
they also gain the ability to utilize any other Trilinos package which
recognizes Epetra classes (such as AztecOO, IFPACK, and others).

In order to use the Anasazi adapter to Epetra, users must include the following
file:
\begin{verbatim}
#include "AnasaziEpetraAdapter.hpp"
\end{verbatim}
This file simply defines specializations of the Anasazi::MultiVecTraits
and Anasazi::Operator\-Traits classes, while also including the Epetra
header files defining the multivector and operator classes.

Because Epetra makes exclusive use of double precision arithmetic, 
Epetra\_Operator and Epetra\_MultiVector are used only with 
scalar type \verb!double!. For brevity, it is useful to declare type definitions
for these classes:
\begin{verbatim}
typedef double ST;
typedef Epetra_MultiVector MV;
typedef Epetra_Operator OP;
\end{verbatim}

\noindent Multivectors will be of type \verb!MV!:
\begin{verbatim}
Teuchos::RCP<MV> X 
   = Teuchos::rcp( new MV(...) );
\end{verbatim}

\noindent Operators can be any subclass of \verb!OP!, for example, an Epetra\_CrsMatrix:
\begin{verbatim}
Teuchos::RCP<OP> A 
   = Teuchos::rcp( new Epetra_CrsMatrix(...) );
\end{verbatim}

The Anasazi interface to Epetra defines a specialization of
Anasazi::MultiVecTraits for Epetra\_MultiVector and a
specialization of Anasazi::OperatorTraits for Epetra\_Operator
applied to Epetra\_MultiVector. Therefore, we can now specify an
eigenproblem and eigensolver utilizing these computational classes. An example
defining an eigenvalue problem and solving the problem using an Anasazi
eigensolver is given in the next section.



\section{Defining and Solving an Eigenvalue Problem}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:anasazi:example}

This section gives sample code for solving a symmetric eigenvalue problem using
the Block Krylov Schur solver manager, Anasazi::BlockKrylovSchurSolMgr. The example code in this section comes from the
Didasko example \TriExe{anasazi/ex1.cpp}.

The first step in solving an eigenvalue problem is to define the eigenvalue
problem. Assume we have chosen classes to represent our scalars, multivectors
and operators as \verb!ST!, \verb!MV! and \verb!OP!, respectively. Given an
operator \verb!A! and a multivector \verb!X! containing initial vectors, both
wrapped in Teuchos::RCP, we might define the eigenproblem as
follows:
\begin{verbatim}
Teuchos::RCP< BasicEigenproblem<ST,MV,OP> > MyProblem 
  = Teuchos::rcp( new BasicEigenproblem<ST,MV,OP>(A,X) );
MyProblem->setHermitian( true );
MyProblem->setNEV( 4 );
bool ret = MyProblem->SetProblem();
if (ret != true) {
   // there should be no error in this example :)
}
\end{verbatim}

The first line creates a Anasazi::BasicEigenproblem object and wraps it in a
Teuchos::\-RCP (Section~\ref{sec:teuchos:RCP}). The second line
specifies the symmetry of the eigenproblem.
The third line specifies the desired
number of eigenvalues and eigenvectors. Lastly, the fourth signals that we have
finished setting up the eigenproblem. This step must be completed before
attempting to solve the problem.

If we were directly using the Anasazi::BlockKrylovSchur eigensolver, we would proceed by
creating all of the support objects needed by the solver: a sort manager, an output
manager, an orthogonalization manager, and a status test.

Instead, we will utilize a solver manager for solving the problem.
First, we create a parameter list to specify the parameters for the solver manager:
\begin{verbatim}
int verb = Anasazi::Warnings + Anasazi::Errors 
         + Anasazi::FinalSummary + Anasazi::TimingDetails;
Teuchos::ParameterList MyPL;
MyPL.set( "Verbosity", verb );
MyPL.set( "Which", "SM" );
MyPL.set( "Block Size", 4 );
MyPL.set( "Num Blocks", 20 );
MyPL.set( "Maximum Restarts", 100 );
MyPL.set( "Convergence Tolerance", 1.0e-8 );
\end{verbatim}

Here, we have asked for the eigensolver to output information regarding errors and
warnings, as well as to provide a final summary after completing all iterations and to
print the timing information collected during the solve. We have also specified the
tolerance for convergence testing (used to construct a status test); the block size and
number of blocks (passed on to the solver); the desired eigenvalues (given to the sort
manager); and the maximum number of restarts (used by the solver manager, the agent
performing the restarts). This solver manager permits other options as well, affecting the
step size as well as the convergence criteria; see the Anasazi documentation.

We now have all of the information needed to declare the solver manager and solve the
problem:
\begin{verbatim}
Anasazi::BlockKrylovSchurSolMgr<ST,MV,OP> 
   MyBlockKrylovSchur(MyProblem, MyPL );
\end{verbatim}
The eigenproblem is solved with the instruction
\begin{verbatim}
Anasazi::ReturnType solverreturn = MyBlockKrylovSchur.solve();
\end{verbatim}

The return value of the solver indicates whether the algorithm succeeded or not; i.e.,
whether the requested number of eigenpairs were found to a sufficient accuracy (as defined
by the solver manager).
Output from \verb!solve()! routine in this example might look as follows:
\begin{verbatim}
================================================================================

                         BlockKrylovSchur Solver Status

The solver is initialized.
The number of iterations performed is 39
The block size is         4
The number of blocks is   20
The current basis size is 4
The number of auxiliary vectors is    0
The number of operations Op*x   is 156

CURRENT RITZ VALUES             
          Ritz Value       Ritz Residual
--------------------------------------------------------------------------------
        1.620281e-01        9.482040e-15
        3.985070e-01        5.712179e-14
        3.985070e-01        2.536671e-14
        6.349859e-01        4.846649e-11

================================================================================

================================================================================

                              TimeMonitor Results

Timer Name                Local time (num calls)    
--------------------------------------------------------------------------------
Operation Op*x            0.001701 (39)             
Sorting Ritz values       0.002926 (3)              
Computing Schur form      0.09797 (3)               
Sorting Schur form        0.01562 (3)               
Computing Ritz vectors    0.000213 (1)              
Orthogonalization         0.08078 (40)              
================================================================================
\end{verbatim}

Eigenvectors and eigenvalues can be retrieved from the eigenproblem (where they were
stored by the solver manager) as follows:
\begin{verbatim}
  Anasazi::Eigensolution<ST,MV> sol = MyProblem->getSolution();
\end{verbatim}

Four examples are provided with the tutorial:
\begin{itemize}
\item \TriExe{anasazi/ex1.cpp}: compute the eigenvectors
corresponding to the smallest eigenvalues for a 2D Laplace problem using the block
Krylov Schur solver
\item \TriExe{anasazi/ex2.cpp}: solves the problem from \verb!ex1! 
using instead the block Davidson eigensolver
\item \TriExe{anasazi/ex3.cpp}: uses the block Krylov Schur solver to solve a
  non-Hermitian convection-diffusion problem
\item \TriExe{anasazi/ex4.cpp}: uses the LOBPCG solver to solve the 2D Laplacian
problem from \verb!ex1!
\end{itemize}

