#if 0
#ifndef SIERRA_MESH_GENERIC_MESH_FUNCTIONS_HPP
#define SIERRA_MESH_GENERIC_MESH_FUNCTIONS_HPP

#include <sierra/mesh/mesh_traits.hpp>
#include <sierra/mesh/field_traits.hpp>

namespace sierra {
namespace mesh {

// Add entity to mesh
template <class Mesh>
typename mesh_traits<Mesh>::entity_key
add_entity( Mesh & mesh );

// Add entity with property to mesh
template <class Mesh>
typename mesh_traits<Mesh>::entity_key
add_entity( const typename mesh_traits<Mesh>::entity_property & prop , Mesh & mesh );

// Destroy_entity
template <class Mesh>
bool
remove_entity( const typename mesh_traits<Mesh>::entity_key & entity_key,
               Mesh & mesh );

// Add relation from entity_from to entity_to without position concept
template <class Mesh>
typename mesh_traits<Mesh>::relation_descriptor
add_relation(const typename mesh_traits<Mesh>::entity_key& entity_from,
             const typename mesh_traits<Mesh>::entity_key& entity_to,
             Mesh & mesh);

// Add relation from entity_from to entity_to with position
template <class Mesh>
typename mesh_traits<Mesh>::relation_descriptor
add_relation(const typename mesh_traits<Mesh>::entity_key& entity_from,
             const typename mesh_traits<Mesh>::entity_key& entity_to,
             const typename mesh_traits<Mesh>::relation_position & relation_position,
             Mesh & mesh);

// Remove this relation from the mesh.
template <class Mesh>
bool
remove_relation( const typename mesh_traits<Mesh>::relation_descriptor& relation,
                 Mesh & mesh );

// Given a relation, get the targetted entity
template <class Mesh>
typename mesh_traits<Mesh>::entity_descriptor
target_entity( const typename mesh_traits<Mesh>::relation_descriptor& relation,
        const Mesh & mesh );

// Generic API:  Get an entity_descriptor from an entity_key
template <class Mesh>
typename mesh_traits<Mesh>::entity_descriptor
entity_key_to_entity_descriptor(const typename mesh_traits<Mesh>::entity_key& entity_key,
                                const Mesh & mesh);

// Generic API:  Get an entity_key from an entity_descriptor
template <class Mesh>
typename mesh_traits<Mesh>::entity_key
entity_descriptor_to_entity_key(const typename mesh_traits<Mesh>::entity_descriptor& entity_d,
                                const Mesh & mesh);

// Generic API:  Get a range to all entities in the mesh.
// Concept: EntityListMesh (similar to VertexListGraph concept for a graph);.
template <class Mesh>
typename mesh_traits<Mesh>::entity_descriptor_range
get_entities(const Mesh & mesh);

// Generic API:  Get a range to all entities in the mesh of a certain entity rank.
// Concept: EntityListMesh (similar to VertexListGraph concept for a graph);.
template <class Mesh>
typename mesh_traits<Mesh>::entity_descriptor_range
get_entities(const typename mesh_traits<Mesh>::entity_rank& entity_rank, const Mesh & mesh);

// Generic API: Get all entities in a bucket
// Concept: HomogeneousSubsetMesh
template <class Mesh>
typename mesh_traits<Mesh>::bucket_entity_range
get_entities(const typename mesh_traits<Mesh>::bucket_key& bucket_key,
             const Mesh & mesh);

// Generic API:  Get a range to all the relations for this entity_local_id
// Concept: ConnectivityMesh (similar to AdjacencyGraph);
template <class Mesh>
typename mesh_traits<Mesh>::relation_range
get_relations(const typename mesh_traits<Mesh>::entity_descriptor& entity,
              const Mesh & mesh );

// Generic API:  Get a range to selected relations for this entity_local_id
// selector is a unary-predicate that takes a relation_descriptor and returns true/false
// Concept: ??? TODO
template <class Mesh, class RelationSelector>
typename mesh_traits<Mesh>::relation_range
get_relations(const typename mesh_traits<Mesh>::entity_descriptor& entity,
              const RelationSelector & select,
              const Mesh & mesh);

// Generic API:  Get a bucket for an entity_descriptor
// Concept: HomogeneousSubsetMesh
template <class Mesh>
typename mesh_traits<Mesh>::bucket_key
get_bucket(const typename mesh_traits<Mesh>::entity_descriptor& entity,
           const Mesh & mesh);

// Generic API:  Get a bucket for an entity_descriptor
// Concept: HomogeneousSubsetMesh
template <class Mesh>
typename mesh_traits<Mesh>::bucket_location
get_bucket_location(const typename mesh_traits<Mesh>::entity_descriptor& entity,
                    const Mesh & mesh);

// Get all buckets in a mesh
// Concept: HomogeneousSubsetMesh
template <class Mesh>
typename mesh_traits<Mesh>::bucket_range
get_buckets( const Mesh & mesh );

// Get all buckets in a mesh for a certain rank
// Concept: HomogeneousSubsetMesh
template <class Mesh>
typename mesh_traits<Mesh>::bucket_range
get_buckets( const typename mesh_traits<Mesh>::entity_rank& entity_rank, const Mesh & mesh );

// Generic API:  Get buckets associated with a selector.
// selector is a unary-predicate that takes a bucket_descriptor and returns true/false
// Concept: HomogeneousSubsetMesh + selector
template <class Mesh, class Selector>
typename mesh_traits<Mesh>::selected_bucket_range
get_buckets( const Selector & selector,
             const Mesh & mesh );

// Generic API:  Get buckets for a particular part
// Concept: Bidirectional HomogeneousSubsetMesh (similar to bidirectional graph);
template <class Mesh>
typename mesh_traits<Mesh>::part_bucket_range
get_buckets( const typename mesh_traits<Mesh>::part_key& part,
             const Mesh & mesh );

// Generic API:  add part to the Mesh.
template <class Mesh>
typename mesh_traits<Mesh>::part_key
add_part( Mesh & mesh );

// Generic API:  add part with property to the Mesh.
template <class Mesh>
typename mesh_traits<Mesh>::part_key
add_part( const typename mesh_traits<Mesh>::part_property& property, Mesh & mesh );

// Generic API:  remove this part from the Mesh.
template <class Mesh>
bool
remove_part( const typename mesh_traits<Mesh>::part_key& part,
             Mesh & mesh );

// Move entity so it
// sits in Parts defined by AddPartInputIterator and
// so it does not sit in Parts defined by RemovePartInputIterator
template <typename AddPartInputIterator, typename RemovePartInputIterator, class Mesh>
typename mesh_traits<Mesh>::bucket_key
move_entity( const typename mesh_traits<Mesh>::entity_key& entity_key,
             AddPartInputIterator add_first, AddPartInputIterator add_last,
             RemovePartInputIterator remove_first, RemovePartInputIterator remove_last,
             Mesh & mesh );

// Generic API:  Get all parts on the mesh.
// Concept: Subsets
template<class Mesh>
typename mesh_traits<Mesh>::part_range
get_parts( const Mesh & mesh );

// Generic API:  Get all Parts associated with a bucket.
// Concept: HomogeneousSubsetMesh
template<class Mesh>
typename mesh_traits<Mesh>::bucket_part_range
get_parts(const typename mesh_traits<Mesh>::bucket_key& bucket,
          const Mesh & mesh);

// Generic API:  Begin modification cycle. Returns true if cycle was not already in progress
template <class Mesh>
bool
modification_begin( Mesh & mesh );

// Generic API:  End modification cycle. Returns true if cycle was in progress.
template <class Mesh>
bool
modification_end( Mesh & mesh );

// Generic API:  Query if we are in a modification cycle
template <class Mesh>
bool
is_modifiable( const Mesh & mesh );

// Access field data
template <class Field, class Mesh>
typename field_traits<Field>::data_type*
get_field_data( const Field& field, typename mesh_traits<Mesh>::entity_descriptor ent_desc, const Mesh& mesh );

//TODO:
//get_field_data_ref
//get_field_data_ptr
//get_field_data_range
//get_field_data_const_ref
//...

} // namespace mesh
} // namespace sierra

#endif // SIERRA_MESH_GENERIC_MESH_FUNCTIONS_HPP
#endif
