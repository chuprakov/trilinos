/*------------------------------------------------------------------------*/
/*                 Copyright 2010 Sandia Corporation.                     */
/*  Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive   */
/*  license for use of this work by or on behalf of the U.S. Government.  */
/*  Export of this program may require a license from the                 */
/*  United States Government.                                             */
/*------------------------------------------------------------------------*/

#include <use_cases/GridFixture.hpp>
#include <stk_mesh/base/BulkModification.hpp>

#include <stk_mesh/base/MetaData.hpp>
#include <stk_mesh/base/BulkData.hpp>
#include <stk_mesh/base/Entity.hpp>
#include <stk_mesh/base/GetEntities.hpp>
#include <stk_mesh/base/Selector.hpp>
#include <stk_mesh/base/GetBuckets.hpp>

#include <stk_mesh/fem/EntityTypes.hpp>
#include <stk_mesh/fem/TopologyHelpers.hpp>
#include <stk_mesh/fem/BoundaryAnalysis.hpp>

#include <stk_util/parallel/ParallelReduce.hpp>

/*
The grid fixture creates the mesh below and skins it
1-16 Quadrilateral<4>
17-41 Nodes
skin ids are generated by the distributed index

17===18===19===20===21
|| 1 |  2 |  3 |  4 ||
22---23---24---25---26
|| 5 |  6 |  7 |  8 ||
27---28---29---30---31
|| 9 | 10 | 11 | 12 ||
32---33---34---35---36
|| 13| 14 | 15 | 16 ||
37===38===39===40===41

This use case will erode the mesh with  iterations

Each iteration will move a selection of faces to the 'dead_part"
Create boundaries between live and dead faces
Destroy nodes and sides that are no longer attached to a live face

1: Move 4, 9 and 10 to the dead part


17===18===19===20
|| 1 |  2 |  3 ||
22---23---24---25===26
|| 5 |  6 |  7 |  8 ||
27===28===29---30---31
          || 11| 12 ||
32===33===34---35---36
|| 13| 14 | 15 | 16 ||
37===38===39===40===41


2: Move faces 2 and 3 to the dead part

17===18
|| 1 ||
22---23===24===25===26
|| 5 |  6 |  7 |  8 ||
27===28===29---30---31
          || 11| 12 ||
32===33===34---35---36
|| 13| 14 | 15 | 16 ||
37===38===39===40===41

3: Move faces 1 and 11 to the dead part

22===23===24===25===26
|| 5 |  6 |  7 |  8 ||
27===28===29===30---31
               || 12||
32===33===34===35---36
|| 13| 14 | 15 | 16 ||
37===38===39===40===41

4: Move faces 6 and 7 to the dead part

22===23        25===26
|| 5 ||        ||  8||
27===28        30---31
               || 12||
32===33===34===35---36
|| 13| 14 | 15 | 16 ||
37===38===39===40===41

5: Move faces 5 and 16 to the dead part

               25===26
               ||  8||
               30---31
               || 12||
32===33===34===35===36
|| 13| 14 | 15 ||
37===38===39===40

6: Move the remaining faces to the dead part


  (nothing to see here)

*/

typedef std::vector<stk::mesh::Entity *> EntityVector;

namespace {

EntityVector entities_to_be_kill( const stk::mesh::BulkData & mesh, int pass);
bool validate_iteration( stk::ParallelMachine pm, GridFixture & fixture, int pass);

void find_sides_to_be_created(
    const stk::mesh::EntitySideVector & boundary,
    const stk::mesh::Selector & select,
    std::vector<stk::mesh::EntitySideComponent> & sides
    )
{

  for (stk::mesh::EntitySideVector::const_iterator itr = boundary.begin();
      itr != boundary.end(); ++itr) {

    const stk::mesh::EntitySideComponent & outside = itr->outside;

    // examine the boundary of the outside of the closure.
    if ( outside.entity != NULL && select(outside.entity->bucket()) ) {

      //make sure the side does not already exist
      const unsigned side_id = outside.side_id;
      const stk::mesh::Entity & entity = * outside.entity;
      stk::mesh::PairIterRelation existing_sides = entity.relations(entity.entity_rank()-1);

      for (; existing_sides.first != existing_sides.second &&
          existing_sides.first->identifier() != side_id ;
          ++existing_sides.first);

      //reached the end -- a new side needs to be created
      if (existing_sides.first == existing_sides.second) {
        sides.push_back(outside);
      }
    }
  }
}

}

bool element_death_use_case_1(stk::ParallelMachine pm)
{

  GridFixture fixture(pm);
  stk::mesh::BulkData& mesh = fixture.bulk_data();
  stk::mesh::MetaData& meta_data = fixture.meta_data();

  stk::mesh::Part & dead_part = *fixture.dead_part();

  stk::mesh::PartVector dead_parts;
  dead_parts.push_back( & dead_part);

  bool passed = true;
  for (int iteration = 0; iteration <=6; ++iteration) {
    //find the entities to kill in this iteration
    EntityVector entities_to_kill = entities_to_be_kill(mesh, iteration);

    // find the parallel-consistent closure of the entities to be killed
    EntityVector entities_closure;
    stk::mesh::find_closure(mesh,
        entities_to_kill,
        entities_closure);


    // find the boundary of the entities we're killing
    stk::mesh::EntitySideVector boundary;
    stk::mesh::boundary_analysis(mesh,
        entities_closure,
        stk::mesh::Face,
        boundary);


    //find the sides that need to be created
    stk::mesh::Selector select_owned = meta_data.locally_owned_part();
    stk::mesh::Selector select_live = ! dead_part ;
    stk::mesh::Selector select_live_and_owned = select_live & select_owned;

    std::vector<stk::mesh::EntitySideComponent> skin;
    find_sides_to_be_created( boundary, select_live_and_owned, skin);


    // Now do the element death.
    // Kill entities by moving them to the dead part.
    mesh.modification_begin();
    for (EntityVector::iterator itr = entities_to_kill.begin();
        itr != entities_to_kill.end(); ++itr) {
      mesh.change_entity_parts(**itr, dead_parts);
    }

    // Ask for new entites to represent the sides between the live and dead entities
    std::vector<size_t> requests(meta_data.entity_type_count(), 0);
    EntityVector requested_entities;
    requests[stk::mesh::Edge] = skin.size();
    mesh.generate_new_entities(requests, requested_entities);

    // Create boundaries between live and dead entities
    for ( size_t i = 0; i < skin.size(); ++i) {
      stk::mesh::Entity & entity = *(skin[i].entity);
      const unsigned side_id  = skin[i].side_id;
      stk::mesh::Entity & side   = * (requested_entities[i]);

      stk::mesh::declare_element_side(entity, side, side_id);
    }
    mesh.modification_end();


    passed &= validate_iteration( pm, fixture, iteration);
  }

  return passed;
}

//----------------------------------------------------------------------------------
namespace {

EntityVector entities_to_be_kill( const stk::mesh::BulkData & mesh, int pass) {

  std::vector<unsigned> entity_ids_to_kill;
  switch(pass) {
    case 0:
      break;
    case 1:
      entity_ids_to_kill.push_back(4);
      entity_ids_to_kill.push_back(9);
      entity_ids_to_kill.push_back(10);
      break;
    case 2:
      entity_ids_to_kill.push_back(2);
      entity_ids_to_kill.push_back(3);
      break;
    case 3:
      entity_ids_to_kill.push_back(1);
      entity_ids_to_kill.push_back(11);
      break;
    case 4:
      entity_ids_to_kill.push_back(6);
      entity_ids_to_kill.push_back(7);
      break;
    case 5:
      entity_ids_to_kill.push_back(5);
      entity_ids_to_kill.push_back(16);
      break;
    case 6:
      entity_ids_to_kill.push_back(8);
      entity_ids_to_kill.push_back(12);
      entity_ids_to_kill.push_back(13);
      entity_ids_to_kill.push_back(14);
      entity_ids_to_kill.push_back(15);
      break;
    default:
      break;
  }

  EntityVector entities_to_kill;
  for (std::vector<unsigned>::const_iterator itr = entity_ids_to_kill.begin();
      itr != entity_ids_to_kill.end(); ++itr) {
    stk::mesh::Entity * temp = mesh.get_entity(stk::mesh::Face, *itr);
    //select the entity only if the current process in the owner
    if (temp != NULL && temp->owner_rank() == mesh.parallel_rank()) {
      entities_to_kill.push_back(temp);
    }
  }
  return entities_to_kill;
}


//----------------------------------------------------------------------------------

bool validate_iteration( stk::ParallelMachine pm, GridFixture & fixture, int pass) {

  stk::mesh::BulkData& mesh = fixture.bulk_data();
  stk::mesh::MetaData& meta_data = fixture.meta_data();

  stk::mesh::Part & dead_part = *fixture.dead_part();

  stk::mesh::Selector select_dead = dead_part & meta_data.locally_owned_part();
  stk::mesh::Selector select_live = !dead_part & meta_data.locally_owned_part();

  int num_dead[3] = {0, 0, 0};
  int num_live[3] = {0, 0, 0};

  for ( int i = 0; i < 3 ; ++i) {
    const std::vector<stk::mesh::Bucket*>& buckets = mesh.buckets( stk::mesh::fem_entity_type(i));
    num_dead[i] = count_selected_entities( select_dead, buckets);
    num_live[i] = count_selected_entities( select_live, buckets);
  }

  stk::all_reduce(pm, stk::ReduceSum<3>(num_dead));
  stk::all_reduce(pm, stk::ReduceSum<3>(num_live));

  bool correct_dead = false;
  bool correct_live = false;

  switch(pass) {
    case 0: {
              correct_dead =
                     (0  == num_dead[0]) &&
                     (0  == num_dead[1]) &&
                     (0  == num_dead[2]);

              correct_live =
                     (25  == num_live[0]) &&
                     (16  == num_live[1]) &&
                     (16  == num_live[2]);

              break;
            }
    case 1: {
              correct_dead =
                     (10 == num_dead[0]) &&
                     (3  == num_dead[1]) &&
                     (3  == num_dead[2]);

              correct_live =
                     (15  == num_live[0]) &&
                     (20  == num_live[1]) &&
                     (13  == num_live[2]);

              break;
            }
    case 2: {
              correct_dead =
                     (14 == num_dead[0]) &&
                     (6  == num_dead[1]) &&
                     (5  == num_dead[2]);

              correct_live =
                     (11  == num_live[0]) &&
                     (20  == num_live[1]) &&
                     (11  == num_live[2]);

              break;
            }
    case 3: {
              correct_dead =
                     (18 == num_dead[0]) &&
                     (10 == num_dead[1]) &&
                     (7  == num_dead[2]);

              correct_live =
                     (7  == num_live[0]) &&
                     (20  == num_live[1]) &&
                     (9  == num_live[2]);

              break;
            }
    case 4: {
              correct_dead =
                     (18 == num_dead[0]) &&
                     (14 == num_dead[1]) &&
                     (9  == num_dead[2]);

              correct_live =
                     (7  == num_live[0]) &&
                     (18  == num_live[1]) &&
                     (7  == num_live[2]);

              break;
            }
    case 5: {
              correct_dead =
                     (21 == num_dead[0]) &&
                     (20 == num_dead[1]) &&
                     (11 == num_dead[2]);

              correct_live =
                     (4  == num_live[0]) &&
                     (14  == num_live[1]) &&
                     (5  == num_live[2]);

              break;
            }
    case 6: {
              correct_dead =
                     (25 == num_dead[0]) &&
                     (34 == num_dead[1]) &&
                     (16 == num_dead[2]);

              correct_live =
                     (0  == num_live[0]) &&
                     (0  == num_live[1]) &&
                     (0  == num_live[2]);

              break;
            }
    default:
            break;
  }

  return correct_dead && correct_live;
}

}

