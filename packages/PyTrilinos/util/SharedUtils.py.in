# @HEADER
# ************************************************************************
# 
#              PyTrilinos: Python Interface to Trilinos
#                 Copyright (2004) Sandia Corporation
# 
# Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
# license for use of this work by or on behalf of the U.S. Government.
# 
# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of the
# License, or (at your option) any later version.
#  
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#  
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA
# Questions? Contact Bill Spotz (wfspotz@sandia.gov) 
# 
# ************************************************************************
# @HEADER

# System imports
import commands
import glob
import os
import sys

# Local import
from MakefileVariables import *

# NumPy import.  There are use cases where the numpy module is not required, so
# we allow this import to fail
try:
    import numpy
except ImportError:
    pass

######################################################################

def sysName():
    """
    Return the system name.  Some system names returned by os.uname have
    irrelevant suffixes which we truncated here.
    """
    uname = os.uname()[0]
    if uname.startswith("CYGWIN"): uname = uname[:6]
    return uname

######################################################################

def buildSharedLibraries():
    """
    Return boolean indicating whether the shared libraries need to be built.
    Returns True if the operating system is either Darwin, Linux or CYGWIN.
    """
    return sysName() in ("Darwin", "Linux", "CYGWIN")

######################################################################

def needsToBeBuilt(target,dependencies):
    """
    Return True if a target file does not exist or is older than any of the
    files in the list of dependencies.
    """
    if not os.path.isfile(target): return True
    targetTime = os.path.getmtime(target)
    for dep in dependencies:
        if os.path.getmtime(dep) > targetTime: return True
    return False

######################################################################

def changeDirectory(path):
    """
    Change directory verbosely
    """
    print "changing directory to", path
    os.chdir(path)

######################################################################

def runCommand(cmd):
    """
    Print a Unix command, run it, print its output and raise an exception if its
    return status is non-zero.
    """
    print cmd
    status, output = commands.getstatusoutput(cmd)
    if output: print output
    if status: raise RuntimeError, "Exit status = %d" % status

######################################################################

def deleteFile(path):
    """
    If a file exists, delete it verbosely; if not, do nothing verbosely.
    """
    if os.path.isfile(path):
        print "deleting", path
        os.remove(path)
    else:
        print "nothing needs to be done for", path

######################################################################

def removeExtensionModules(path):
    """
    Remove every file whose name matches the pattern _*.so under the given
    path.
    """
    if True: return
    print "removing extension modules"
    runCommand("find %s -name _*.so -print -delete" % path)

######################################################################

def getCompileOptions(makeMacros):
    """
    Given a set of Makefile macros, extract the set of compile options, uniquify
    them, and return a list of those options with any 'illegal' options removed.
    """
    illegalOptions = ["-ansi", "-pedantic"]
    compileOptions = makeMacros["CPPFLAGS"].split() + \
                     makeMacros["CXXFLAGS"].split()
    uniquifyList(compileOptions)
    for opt in illegalOptions:
        try:
            compileOptions.remove(opt)
        except ValueError:
            pass
    return compileOptions

######################################################################

class SharedTrilinosBuilder:
    """
    Class for performing various build processes (build, install, clean,
    uninstall) related to converting a Trilinos library from static to dynamic.
    """

    def __init__(self,package):
        """
        Initialize a SharedTrilinosBuilder object for the specified Trilinos
        package.  The package name should be in its capitalized form.
        """
        self.package      = package
        self.packageLower = package.lower()
        self.packageUpper = package.upper()
        self.sysName      = sysName()
        self.libPathVar   = self.getLibPathVarName()
        self.libOption    = "-l"  + self.packageLower
        self.dylibName    = self.getDylibName()
        self.getBuildDirs()
        self.libVar       = self.getLibVarName()
        self.thisDir      = os.getcwd()
        self.absDylibName = os.path.join(self.thisDir, self.dylibName)
        self.makeMacros   = self.getMakeMacros()
        self.linkCmd      = self.getLinkCmd()
        self.supported    = buildSharedLibraries()

    ######################################################################

    def getBuildDirs(self):
        """
        Given a lower-case package name, implement specialized rules to obtain
        the top build directory and the build directory for the given package.
        The results are stored in self.topBuildDir and self.buildDir.
        """

        # Initialization
        self.buildDir    = None
        self.topBuildDir = None
        pkg1             = None
        pkg2             = None
        loca             = "loca"
        nox              = "nox"
        stratimikos      = "stratimikos"
        thyra            = "thyra"

        # Thyra and Stratimikos follow similar rules
        if self.packageLower.startswith(thyra):
            pkg1 = thyra
            pkg2 = self.packageLower.replace(thyra,"")
        if self.packageLower.startswith(stratimikos):
            pkg1 = stratimikos
            pkg2 = self.packageLower.replace(stratimikos,"")
        if pkg1 and pkg2:
            self.topBuildDir = os.path.join("..", "..", pkg1, "adapters",
                                              pkg2)

        # NOX can be a little specialized
        if self.packageLower.startswith(nox):
            pkg2 = self.packageLower.replace(nox,"")
            self.topBuildDir = os.path.join("..", "..", "nox")
            if pkg2: self.buildDir = os.path.join(self.topBuildDir,
                                                    "src-"+pkg2)

        # LOCA is under the NOX package
        if self.packageLower.startswith(loca):
            pkg2 = self.packageLower.replace(loca,"")
            self.topBuildDir = os.path.join("..", "..", "nox")
            if pkg2: self.buildDir = os.path.join(self.topBuildDir,
                                                    "src-loca", "src-"+pkg2)
            else:    self.buildDir = os.path.join(self.topBuildDir,
                                                    "src-loca", "src")

        # MOOCHO/Thyra
        if self.packageLower == "moochothyra":
            self.topBuildDir = os.path.join("..", "..", "moocho")
            self.buildDir    = os.path.join(self.topBuildDir, "thyra", "src")

        # Anasazi/Epetra
        if self.packageLower == "anasaziepetra":
            self.topBuildDir = os.path.join("..", "..", "anasazi")
            self.buildDir    = os.path.join(self.topBuildDir, "epetra", "src")

        # Default behavior
        if not self.topBuildDir:
            self.topBuildDir = os.path.join("..", "..", self.packageLower)
        if not self.buildDir:
            self.buildDir = os.path.join(self.topBuildDir, "src")

    ######################################################################

    def getLibVarName(self):
        """
        Determine the name of the Makefile variable that contains the names of
        the libraries to link against.
        """
        special = ["THYRA",
                   "STRATIMIKOS",
                   "NOX",
                   "LOCA",
                   "MOOCHO"]
        prefix = self.packageUpper
        for package in special:
            if self.packageUpper.startswith(package):
                prefix = package
                break
        return prefix + "_LIBS"

    ######################################################################

    def getLibPathVarName(self):
        """
        Determine the name of environment variable used to specify the (dynamic)
        library load path.
        """
        if self.sysName in ("Darwin",):
            return "DYLD_LIBRARY_PATH"
        else:
            return "LD_LIBRARY_PATH"

    ######################################################################

    def getDylibName(self):
        """
        Determine what the dynamic library name should be, based on the type of
        system we are on.
        """
        if self.sysName in ("Darwin",):
            return "lib" + self.packageLower + ".dylib"
        elif self.sysName in ("Linux",):
            return "lib" + self.packageLower + ".so"
        elif self.sysName in ("CYGWIN",):
            return "cyg" + self.packageLower + ".dll"
        else:
            return "lib" + self.packageLower + ".?"

    ######################################################################

    def getMakeMacros(self):
        """
        Obtain the dictionary of Makefile macros appropriate for PyTrilinos.
        """
        return processMakefile("Makefile")

    ######################################################################

    def getLinkCmd(self):
        """
        Determine the appropriate dynamic link command for this Trilinos
        package.
        """
        cxx = self.makeMacros["CXX"]
        default = self.makeMacros.get(self.libVar, "")
        ldFlags = self.makeMacros.get(self.packageUpper + "_PYTHON_LIBS",
                                        default)
        ldFlags = ldFlags.replace(self.libOption+" ", "")  # Remove -lpackage
        ldFlags = "-L" + self.thisDir + " " + ldFlags
        if self.sysName == "Darwin":
            options = "-dynamiclib -undefined dynamic_lookup"
            linkCmd = "%s %s -o %s *.o -single_module %s" % (cxx,
                                                             options,
                                                             self.dylibName,
                                                             ldFlags)
        elif self.sysName == "Linux":
            options = "-shared -Wl,-soname,%s" % self.dylibName
            linkCmd = "%s %s -o %s *.o %s" % (cxx,
                                              options,
                                              self.dylibName,
                                              ldFlags)
        elif self.sysName == "CYGWIN":
            options = "-shared -Wl,--out-implib=lib%s.dll.a " + \
                      "=Wl,--export-all-symbols -Wl,--enable-auto-import" + \
                      "-Wl,--whole-archive *.o" + \
                      "-Wl,--no-whole-archive %s" % self.packageLower
                                                     
            linkCmd = "%s %s -o %s *.o -Wl,--no-whole-archive %s" % \
                      (cxx, options, self.dylibName, ldFlags)
        else:
            linkCmd = "echo %s not supported" % self.sysName
        return linkCmd

    ######################################################################

    def buildShared(self):
        """
        Change directory to the Trilinos package and, if necessary, re-link the
        package library as a dynamic/shared library.
        """
        if not self.supported: return

        # Build a new shared library
        if needsToBeBuilt(self.absDylibName,
                          glob.glob(os.path.join(self.buildDir,"*.o"))):
            print "\nLinking", self.package, "as a shared library"
            changeDirectory(self.buildDir)
            runCommand(self.linkCmd)
            print "Moving", self.dylibName, "to", self.absDylibName
            os.rename(self.dylibName, self.absDylibName)
            # Restore the current working directory
            changeDirectory(self.thisDir)

    ######################################################################

    def clean(self):
        """
        Remove all files created by the buildShared() method.
        """
        if not self.supported: return

        # Remove the shared library
        deleteFile(self.dylibName)

    ######################################################################

    def install(self, installDir):
        """
        Install the new shared Trilinos library and the newly linked python
        extension module in the appropriate directories.
        """
        if not self.supported: return

        # Initialize
        install    = self.makeMacros["INSTALL"]

        # Install the shared library and python module
        runCommand(" ".join([install, self.dylibName, installDir]))

    ######################################################################

    def uninstall(self):
        """
        Uninstall the shared Trilinos library.
        """
        if not self.supported: return

        # Initialize
        installDir = self.makeMacros["libdir"]

        # Uninstall the shared library and python module
        deleteFile(os.path.join(installDir, self.dylibName))

######################################################################

class SharedPyTrilinosBuilder(SharedTrilinosBuilder):
    """
    A specialized SharedTrilinosBuilder class for the PyTrilinos shared library.
    The primary purpose of this class is to redefine the buildShared and clean
    methods to deal with the swig runtime header and PyTrilinos object files.
    """

    def __init__(self):
        SharedTrilinosBuilder.__init__(self, "PyTrilinos")
        self.buildDir    = os.path.join("..","src")
        self.swigRuntime = "swigpyrun.h"
        top_srcdir       = self.makeMacros["top_srcdir"]
        self.srcDir      = os.path.join(top_srcdir, "src")
        self.getSources()
        self.headers     = [src.replace(".cpp",".h") for src in self.sources]
        self.objects     = [os.path.join(self.buildDir,
                                         os.path.basename(src).replace(".cpp",".o"))
                            for src in self.sources]
        self.linkCmd    += uniquifyString(self.makeMacros.get("EPETRA_LIBS","") + 
                                          " " + self.makeMacros.get("TEUCHOS_LIBS","")
                                          + " " + self.makeMacros.get("EPETRAEXT_LIBS",""))

    ######################################################################

    def getSources(self):
        """
        Get the list of sources, depending on which packages are enabled and
        disabled.
        """
        # Start with all of the source files
        self.sources = glob.glob(os.path.join(self.srcDir, "*.cpp"))
        # If Teuchos not enabled, remove Teuchos source files
        if self.makeMacros["ENABLE_TEUCHOS"] != "true":
            self.sources = [src for src in self.sources if "Teuchos" not in src]
        # If Epetra not enabled, remove Epetra source files
        if self.makeMacros["ENABLE_EPETRA"] != "true":
            self.sources = [src for src in self.sources if "Epetra" not in src]

    ######################################################################

    def getCompileCmd(self, src, obj):
        """
        Given a source file name and an object file name, return a compile
        command.
        """
        try:
            numpy_include = " -I" + numpy.get_include()
        except AttributeError:
            numpy_include = " -I" + numpy.get_numpy_include()
        cxx      = self.makeMacros["CXX"]
        includes = "-I" + os.path.join(sys.prefix, "include", "python%d.%d" %
                                       (sys.version_info[0], sys.version_info[1]))
        if "Teuchos" in src:
            includes += " " + self.makeMacros.get("TEUCHOS_INCLUDES","")
            includes += " -I" + self.buildDir
        if "Epetra" in src:
            includes += " " + self.makeMacros.get("EPETRA_INCLUDES","")
        if "NumPy" in src:
            includes += numpy_include
        if "PyModelEvaluator.cpp" in src:
            includes += " " + self.makeMacros.get("EPETRAEXT_INCLUDES","")
            includes += " -I" + self.buildDir
            includes += numpy_include
        options = " ".join(getCompileOptions(self.makeMacros))
        if int(numpy.__version__.split(".")[0]) > 0:
            options += " -DNUMPY_NOPREFIX"
        return " ".join([cxx, includes, options, "-c", src, "-o", obj])

    ######################################################################

    def buildShared(self):
        """
        The specialized buildShared method for the PyTrilinos shared library
        must create the swig runtime header file and compile the PyTrilinos
        source files before linking them into the shared library.
        """
        if not self.supported: return

        # Build the swig runtime header file
        swigRuntime = os.path.join(self.buildDir, self.swigRuntime)
        if needsToBeBuilt(swigRuntime, [ ]):
            print "\nBuilding the swig runtime header file"
            changeDirectory(self.buildDir)
            swig       = self.makeMacros["SWIG"           ]
            swigPython = self.makeMacros["SWIG_PYTHON_OPT"]
            runCommand(" ".join([swig, swigPython, "-external-runtime"]))
            changeDirectory(self.thisDir)

        # Compile the PyTrilinos sources
        count = 0
        for src,hdr,obj in zip(self.sources, self.headers, self.objects):
            if needsToBeBuilt(obj, [src,hdr]):
                if count == 0:
                    print "\nCompiling the PyTrilinos source files"
                runCommand(self.getCompileCmd(src, obj))
                count += 1

        # Create the shared PyTrilinos library
        if len(self.sources) > 0:
            SharedTrilinosBuilder.buildShared(self)
        
    ######################################################################

    def clean(self):
        """
        The specialized clean method for the PyTrilinos shared library also
        deletes the swig runtime header file and the PyTrilinos object files in
        addition to removing the shared library itself.
        """
        if not self.supported: return

        # Remove the swig runtime header file
        deleteFile(os.path.join(self.buildDir, self.swigRuntime))

        # Remove PyTrilinos object files
        for obj in self.objects:
            deleteFile(obj)

        # Remove the shared library
        SharedTrilinosBuilder.clean(self)
