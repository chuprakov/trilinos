--------------------------------------------
How to CMakeify an Existing Trilinos Package
--------------------------------------------

Last updated: 2008/11/15
------------------------

Here, we describe how to add full CMake/CTest support to an existing
Trilinos package.  The process of providing CMake/CTest support for a
Trilinos package will be referred to as "CMakeifying" a package.  For
this howto, we will draw on examples from existing CMakeified packages
like Thyra (thyra), Epetra (epetra), and EpetraExt (epetraext).

Let PACKAGE_NAME and PACKAGE_DIR represent the package name and the
directory name for the Trilinos package that you are CMakeifying.  For
example, for AztecOO, this would be:

  PACKAGE_NAME = AztecOO
  PACKAGE_DIR = aztecoo

Note that in general for any directory where you have a Makefile.am
file you will need to create the equivalent CMakeLists.txt file.
Note, however, there is no such thing as a configure.ac file with
CMake so once you create the CMakeLists.txt files and tie them
together with ADD_SUBDIRECTORY(...) calls, you are finished!

Here are the steps for CMakeifying a Trilinos package:


1) Add/enable the package in Trilinos/cmake/TrilinosPackages.cmake

Add the package name PACKAGE_NAME and the package directory name
PACKAGE_DIR to the list of supported Trilinos packages in the file
Trilinos/cmake/TrilinosPackages.cmake in the variable
Trilinos_PACKAGES_AND_DIRS_AND_ENABLES.

Or, if this package is already listed but is disabled, change the
default ENABLE column from OFF to empty "".

NOTE: You have to list the packages in strictly increasing order of
dependencies.  Don't worry, if you get the order wrong, you will find
this out at configure time automatically with a nice error message.


2) Create the package's base-level PACKAGE_DIR/CMakeLists.txt file

Copy the top-level CMakeLists.txt for:

  Trilinos/packages/epetraext/CMakeLists.txt

(or any other Trilinos package) to:

  Trilinos/packages/PACKAGE_DIR/CMakeLists.txt

In the new PACKAGE_DIR/CMakeLists.txt file, change the name of the
package in the TRILINOS_PACKAGE(...) macro to the name of the Trilinos
package PACKAGE_NAME.

NOTE: If the name you pass into TRILINOS_PACKAGE(...) is not the same
as you specified in the Trilinos_PACKAGES variable in the base-level
CMakeLists.txt file, then you will get an error message telling you
this.

Modify this CMakeLists.txt file to pull in ADD_SUBDIRECTORY(...) calls
to include other CMakeLists.txt files for the libraries and the
tests/examples for the package.

NOTE: You must include the ADD_SUBDIRETORY(...) calls in the order of
the build dependencies.  For example, you have to add the subdirectory
for the library(s) in 'src' before the subdirectories in 'test' or
'example'.

Special cases:

2.a) Overridding an optional intra-package enable

See turning off Zoltan support without MPI in packages/ml/CMakeLists.txt


3) Create the directory PACKAGE_DIR/cmake

This directory should already be created for your package.  If this is
a new package, then it can be created with:

  $ cd Trilinos/packages/PACKAGE_DIR
  $ mkdir cmake
  $ cvs add cmake


4) Create or modify the PACKAGE_DIR/cmake/Dependencies.cmake file

The dependencies file:

  Trilinos/packages/PACKAGE_DIR/cmake/Dependencies.cmake

should already exist for this package.  If not, then copy a
Dependencies.cmake file from some other package.

You have to modify PACKAGE_DIR/cmake/Dependencies.cmake for this
package's various dependencies.

To get the list of package dependencies, look at the file

  Trilinos/packages/PACKAGE_DIR/Makefile.export.PACKAGE_DIR

for hints as to what packages to list here.  This file does not always list
all of the test dependencies so you will need to look in other places also.
Another place to look for test dependencies is look for the M4 macro
TAC_ARG_ENABLE_CAN_USE_PACKAGE(...) used in:

  Trilinos/packages/PACKAGE_DIR/configure.ac

You should be able to find all of the optional dependencies in the above two
files.  However, you may not find all of the required test dependencies.  The
last of those will have to be discovered in the Makefile.am files in the
various test directories.

NOTE: Don't worry if you don't find all of the package dependencies right
away.  If you leave any out, the compile/link cycle will tell you which ones
you need to add.  It is better to initially understate the package
dependencies than to overstate them because you can catch the former mistake
but not the later.  The danger in overstating package dependencies is that it
will take longer to test code before you check in because you will have to
build more libraries and test executables than you really need to.

NOTE: If a package is included in a 'REQUIRED' list, then it does not
need to be included in the corresponding 'OPTIONAL' list.

NOTE: Once you list out these package dependencies, you will never
directly refer to these packages again.  All of the dependency
handling is performed automatically by the provided macros.  You can
only overstate the dependencies, you can never understate them.

NOTE: The top-level CMake support code will automatically create user
cache variables for packages and TPLs that exist in the lists
[LIB,TEST]_OPTIONAL_DEP_PACKAGES and [LIB,TEST]_OPTIONAL_DEP_TPLS.
For [LIB,TEST]_OPTIONAL_DEP_PACKAGES, user cache variables with the
name PACKAGE_ENABLE_DEPPACKAGE will be created where PACKAGE is the
name of this package (i.e. ML, NOX, EpetraExt, etc.) and DEPPACKAGE is
the name of the listed dependent package.  Also, regular variables
will be created with the name HAVE_UCPACKAGE_UCDEPPACKAGES where
UCPACKAGE and UCDEPPACKAGES are the respective upper-case names of
PACKAGE and DEPPACKAGE.  The same applies to the optional TPLs listed
in [LIB,TEST]_OPTIONAL_DEP_TPLS.


5) Copy and modify the PACKAGE_config.h.in file

Copy the package's autotools-generated PACKAGE_config.h.in file from:

  Trilinos/packages/PACKAGE_DIR/src/PACKAGE_config.h.in

to

  Trilinos/packages/PACKAGE_DIR/cmake/PACKAGE_config.h.in

You will then to need to manually modify the file
PACKAGE_DIR/cmake/PACKAGE_config.h.in to replace '#undef' with
'#cmakedefine'.  Also use this opportunity to strip out the mess of
extra macro defines that the package does not need.  Compare the
files:

  Trilinos/packages/epetraext/cmake/EpetraExt_config.h.in

with 

  Trilinos/packages/epetraext/src/EpetraExt_config.h.in

to see the significant reduction in the amount of junk you can clean
out.

Typically, you should clean out obsolete macros related if standard
C++ header files exist or not.  Typically, you need to keep the macros
that define conditional code.


6) Create the package's library PACKAGE_DIR/src/CMakeLists.txt file

Most Trilinos packages just create a single library from a single
Makefile.am file with autotools.  This is the case that is described
here.

Start by copying over an existing library CMakelists file from another
package.  For example, copy the file:

  Trilinos/packages/teuchos/src/CMakeLists.txt

(or any other Trilinos package) to:

  Trilinos/packages/PACKAGE_DIR/src/CMakeLists.txt

Now, modify the file PACKAGE_DIR/src/CMakeLists.txt as follows:

6.a) Specify the list of HEADERS and SOURCES:

Copy the list of headers and sources from:

  Trilinos/packages/PACKAGE_DIR/src/Makefile.am

to

  Trilinos/packages/PACKAGE_DIR/src/CMakeLists.txt

and make the appropriate modifications.  If you compare the files

  Trilinos/packages/teuchos/src/CMakeLists.txt

to

  Trilinos/packages/teuchos/src/Makefile.am

you will see the nature of the changes to these lists that is needed.

NOTE: We need to move to globing the source files instead of listing
them out in order to make the SIERRA BJAM Jamfiles more maintainable.

Also, if you have headers that are not part of you "public" interface
and you do not want to install, then see zoltan/src/CMakeLists.txt for
an example of how to do that.

6.b) Specify the name of the library(s) being created

Set the name of the library being created in the macro call
TRILINOS_PACKAGE_ADD_LIBRARY(...).

NOTE: The name of this library will never be manually listed again in
any other build-system file.  The macros take care of everything
automatically.

6.c) Multiple libraries

If the package has more than one library in the same CMakeList.txt
file, see epetra/src/CMakeLists.txt for an example.  If the pacakge
has more than one library spread out across several CMakeLists.txt
file, see thyra/src/CMakeLists.txt,
thyra/adapters/epetra/src/CMakeLists.txt, and
thyra/adapters/epetraext/src/CMakeLists.txt for an example.

6.d) Test-only libraries

If you package has test-only libraries, then look at how this is
handled in isorropia/utils/CMakeLists.txt.  These test-only libraries
are not added to the list of offical package libraries but are added
to the link line when linking tests and examples for this package.


7) Add the CMakeLists.txt files for the tests and examples

Adding the CMakeLists.txt files for all of the tests and examples is
perhaps the most time consuming part of CMakeifying a Trilinos
package.  Note that with the CMake system, you can (and should) list
the executables and the tests in the same CMakeLists.txt file.  This
helps keep things together and easier to maintain.

Comparing the autotools Makefile.am files in epetraext/test with the
CMakeLists.txt files in those same directories provides a good example
of how to write the CMakeLists.txt files for tests and examples.

In general, most test/example executables and the accompanying test
harness test can be added in one shot with the
TRILINOS_ADD_EXECUTABLE_AND_TEST(...) macro.  For cases where you need
finer control, you can use the separate macros
TRILINOS_ADD_EXECUTABLE(...) and TRILINOS_ADD_TEST(...).

To see lots of examples of how to use the macros
TRILINOS_ADD_EXECUTABLE(...) TRILINOS_ADD_TEST(...), and
TRILINOS_ADD_EXECUTABLE_AND_TEST(...) look at examples in the packages
teuchos, epetra, epetraext, and thyra.  Don't be lazy, look at working
examples in other packages!  Look for usage examples, for instance,
with:

  $ find . -name CMakeLists.txt -exec grep -nH 'TRILINOS_ADD_EXECUTABLE' {} \;

Above, replace TRILINOS_ADD_EXECUTABLE with
TRILINOS_ADD_EXECUTABLE_AND_TEST and TRILINOS_ADD_TEST for all of the
examples.

A few points are worth mentioning:

7.a) You must name the CMake-build executables exactly the same as in
the autotools system

To see what the name is of the autotools-generated executables, look
in the Makefile.am file in the same directory and in
PACKAGE_DIR/test/definition.

NOTE: The CMake build system automaticlaly appends the name of the
package to every test and example exectuable.  This is because CMake
needs the target names to be globaly unique across all of Trilinos and
it helps to have all of the targets for a package sorted together in
MS Visual Studio projects.

7.b) You must add tests for every test case that is listed in
PACKAGE_DIR/test/defintion

The package thyra has some of the more varied examples of how to
specify CTest tests for a variety of use cases.  It is worth your time
to look through some of these examples.


8) Configure, build, and test

Once you have completed up through step 4 and have the files
PACKAGE_DIR/CMakeLists.txt (at least a skeleton) and
PACKAGE_DIR/cmake/Dependinces.cmake in place, you can start
configuring with cmake to test that things are working correctly.  It
is helpful to define -DTrilinos_VERBOSE_CONFIGURE:BOOL=ON when you
configure so that you can see what libraries, executables, and tests
are being added.  You should always try to test your changes in small
increments so that it is easy to debug problems.  If you do need to
debug, puting in print statements using the MESSAGE(...) command and
the helper function PRINT_VAR(...) is very useful.

8.a) Run the CTest tests

As you add test/example executables and CTest tests, you can run them
for your package as:

  $ ctest -R '^PACKAGE_NAME_' -W 100

(where PACKAGE_NAME = Epetra, EpetraExt, etc.)

8.b) Run the perl-based test harness

You can also run the tests/examples through the perl-based system by
using:

  $ make PACKAGE_NAME-runtests-serial

or 

  $ make PACKAGE_NAME-runtests-mpi

(where PACKAGE_NAME = Epetra, EpetraExt, etc.)

8.c) Verify that the CTest tests are the same as the perl-based tests

One of the final steps in completing the CMakeification of a Trilinos
package is to check to make sure that all of the same tests/examples
that are built and run with the Autotools system are also being built
and run as part of the CMake system.  To do this, you need to
configure the package you are CMakeifying along with the rest of
Trilinos the same way with the Autotools system as with the CMake
system (you will just have to figure out how to do that).

Once you have your package and dependent packages configured with
Autotools and CMake in the same way, you must run the autotools-built
tests as:

  $ cd AUTOTOOLS_BUILD_DIR/packages/PACKAGE_DIR
  $ make runtests-serial

The detailed output from the above 'make runtests-serial' command (or
'make runtests-mpi' command with the rest of the arguments needed for
running MPI) is in the file:

  AUTOTOOLS_BUILD_DIR/packages/PACKAGE_DIR/test/runtests-results/

(note, you will have to go to the most recent date directory)

The above output must be the same that you get by building with the
CMake system and running the tests with:

  $ CMAKE_BUILD_DIR
  $ make PACKAGE_NAME-runtests-serial

The detailed output from 'make PACKAGE_NAME-runtests-serial' (or 'make
PACKAGE_NAME-runtests-mpi') is in the output file:

  CMAKE_BUILD_DIR/runtests-results/

(note, you will have to go to the most recent date directory)

The output in:

  AUTOTOOLS_BUILD_DIR/packages/PACKAGE_DIR/test/runtests-results/

must match the output in:

  CMAKE_BUILD_DIR/runtests-results/

for equivalent test runs.

As the final verification step, you need to run the tests through
CTest with:

  $ cd CMAKE_BUILD_DIR
  $ ctest -R '^PACKAGE_NAME_' -W 100

and verify that the output in:

  CMAKE_BUILD_DIR/Testing/Temporary/LastTest.log

is equivalent to the output run by 'make PACKAGE_NAME-runtests-serial'
(or 'make PACKAGE_NAME-runtests-mpi' for an MPI build) that is given
in:

  CMAKE_BUILD_DIR/runtests-results/

I don't think you can easily automate these types of comparisons and I
think the package developers themselves must be the ones to ultimately
verify that the CMakeification of their package is complete by
carefully looking at the various test outputs described above.
