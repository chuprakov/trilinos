include(AppendSet)
include(AppendGlobalSet)
include(Split)
include(Join)
include(PrintVar)

# this macro expands produces a list of all combinations of a variable number of lists:
# called like TRIBITS_ETI_TYPE_EXPANSION(setvar "T=t1,t2,t3" "S=s1,s2" "V=v1")
# returns setvar="T=T1 S=s1 V=v1;T=T1 S=s2 V=v1;
#                 T=T2 S=s1 V=v1;T=T2 S=s2 V=v1;
#                 T=T3 S=s1 V=v1;T=T3 S=s2 V=v1"
FUNCTION(TRIBITS_ETI_TYPE_EXPANSION outvar first_list)
  # extract the field name and the list of types
  STRING(REGEX REPLACE "([^=]*)=(.*)" "\\1" label "${first_list}")
  STRING(REGEX REPLACE "([^=]*)=(.*)" "\\2" tlist "${first_list}")
  SPLIT("${tlist}" "\\|" tlist)
  IF ("${${outvar}}" STREQUAL "")
    SET(accumulate OFF)
  ELSE()
    SET(accumulate ON)
  ENDIF()
  LIST(LENGTH tlist tlist_len)
  IF (${ARGC} GREATER 2)
    TRIBITS_ETI_TYPE_EXPANSION(sub ${ARGN})
    FOREACH(t ${tlist})
      STRING(STRIP "${t}" t)
      SET(t "{${t}}")
      FOREACH(s ${sub})
        LIST(APPEND result "${label}=${t} ${s}")
      ENDFOREACH()
    ENDFOREACH()
  ELSE()
    FOREACH(t ${tlist})
      STRING(STRIP "${t}" t)
      SET(t "{${t}}")
      LIST(APPEND result "${label}=${t}")
    ENDFOREACH()
  ENDIF()
  IF (accumulate)
    SET(${outvar} "${${outvar}};${result}" PARENT_SCOPE)
  ELSE()
    SET(${outvar} "${result}"              PARENT_SCOPE)
  ENDIF()
ENDFUNCTION()

# Explode an ETI set into a variable number of named component fields
FUNCTION(TRIBITS_ETI_EXPLODE fields etivar outvar)
  LIST(LENGTH fields numfields)
  MATH(EXPR numfieldsm1 "${numfields}-1")
  foreach (i RANGE 0 ${numfieldsm1})
    LIST(GET fields ${i} field)
    SET(tmp "")
    STRING(REGEX REPLACE ".*${field}=([^ ]*).*" "\\1" tmp ${etivar})
    LIST(APPEND result ${tmp})
  endforeach()
  SPLIT("${result}" "," result)
  SET(${outvar} "${result}" PARENT_SCOPE)
ENDFUNCTION()

# effectively, a tupled regex, wrapped in a for loop
# given a list of processed excludes (a list of comma-separated tuples of regexes), 
# determine whether processed_inst (a comma-separated tuple of types) is matched
# if the instantiation matches one of the exclusions, result is set true
FUNCTION(TRIBITS_ETI_CHECK_EXCLUSION processed_excludes processed_inst excluded)
  STRING(REPLACE "," ";" "${processed_inst}" processed_inst)
  LIST(LENGTH processed_inst numfields)
  MATH(EXPR "${numfields}-1" NFm1)
  SET(${excluded} OFF PARENT_SCOPE)
  # check to see whether this is excluded or not
  FOREACH(excl ${processed_excludes})
    STRING(REPLACE "," ";" "${excl}" excl)
    SET(lcltest ON)
    FOREACH(i RANGE 0 NFm1)
      LIST(GET processed_inst ${i} f)
      LIST(GET excl ${i} e)
      IF (NOT ${f} MATCHES ${e})
        SET(lcltest OFF)
        BREAK()
      ENDIF()
    ENDFOREACH()
    IF(lcltest) 
      SET(${excluded} ON PARENT_SCOPE)
      IF (${PROJECT}_VERBOSE_CONFIGURE) 
        MESSAGE(STATUS "-- Instantiation excluded by ${excl}")
      ENDIF()
      RETURN()
    ENDIF()
  ENDFOREACH()
ENDFUNCTION()

# given a list of field names and list of macrofields, translate the 
# field names in macrofields into indices corresponding to the position in 
# the list of field names
FUNCTION(TRIBITS_ETI_INDEX_MACRO_FIELDS etifields macrofields indexvar)
  STRING(REPLACE "," ";" macrofields ${macrofields})
  FOREACH(mf ${macrofields})
    LIST(FIND etifields ${mf} ind)
    IF(${ind} EQUAL -1)
      MESSAGE(FATAL_ERROR "Macro variable ${mf} not found in list of fields: ${etifields}")
    ENDIF()
    LIST(APPEND inds ${ind})
  ENDFOREACH()
  SET(${indexvar} ${inds} PARENT_SCOPE)
ENDFUNCTION()

# given a macro name and a list of tuples, generate a macro string
FUNCTION(TRIBITS_ETI_BUILD_MACRO_STRING macroname tuplelist outvar)
  SET(str "#define ${macroname}(INSTMACRO) \\\n")
  FOREACH(tuple ${tuplelist})
    SET(str "${str}\tINSTMACRO(${tuple})\\\n")
  ENDFOREACH()
  SET(str "${str}\n")
  SET(${outvar} ${str} PARENT_SCOPE)
ENDFUNCTION()

# utility for adding eti support to another package's library set
MACRO(TRIBITS_ADD_ETI_INSTANTIATIONS PACKAGE)
  IF(${PROJECT_NAME}_VERBOSE_CONFIGURE)
    MESSAGE(STATUS "Adding instantiations to ${PACKAGE} library set...")
  ENDIF()
  APPEND_GLOBAL_SET(${PACKAGE}_ETI_LIBRARYSET ${ARGN})
ENDMACRO()

# generate the macros
FUNCTION(TRIBITS_GENERATE_ETI_MACROS etifields etisetvar etiexcludelist)
  SPLIT("${etifields}" "\\|" etifields)
  IF(${PROJECT}_VERBOSE_CONFIGURE)
    MESSAGE(STATUS "ETI fields: ${etifields}")
    MESSAGE(STATUS "ETI set: ${etisetvar}")
    MESSAGE(STATUS "ETI excludes: ${etiexcludelist}")
  ENDIF()
  # we make lists of tuples first, because we want to make sure they don't have duplicates
  # this algorithm is O(N^2) in the number of instantiations in etisetvar
  MATH(EXPR num_macros "(${ARGC}-3)/2")
  IF(${num_macros} EQUAL 0)
    RETURN()
  ENDIF()
  # process macro fields into a list of indices
  FOREACH(m RANGE 1 ${num_macros})
    MATH(EXPR m2   "(${m}-1)*2")
    MATH(EXPR m2p1 "${m2}+1")
    LIST(GET ARGN ${m2}   macroarg)
    LIST(GET ARGN ${m2p1} macrovar${m})
    STRING(REGEX REPLACE "^(.*)\\(.*"     "\\1" macroname${m} ${macroarg})
    STRING(REGEX REPLACE "^.*\\((.*)\\)$" "\\1" macrofields${m} ${macroarg})
    TRIBITS_ETI_INDEX_MACRO_FIELDS("${etifields}" "${macrofields${m}}" macroindex${m})
    IF(${PROJECT}_VERBOSE_CONFIGURE)
      MESSAGE(STATUS "Parsed macro ${macroname${m}}(${macrofields${m}}) into variable ${macrovar${m}} (index list ${macroindex${m}})")
    ENDIF()
  ENDFOREACH()
  # process the exclusions once
  FOREACH(excl ${etiexcludelist})
    TRIBITS_ETI_EXPLODE("${etifields}" "${excl}" excl)
    LIST(APPEND processed_excludes "${excl}")
  ENDFOREACH()
  LIST(LENGTH etifields numfields)
  MATH(EXPR NFm1 "${numfields}-1")
  FOREACH(inst ${etisetvar})
    # strip out the types using regex; we're not assuming that they are ordered
    IF (${PROJECT}_VERBOSE_CONFIGURE) 
      MESSAGE(STATUS "Processing instantiation: ${inst}") # comment
    ENDIF()
    TRIBITS_ETI_EXPLODE("${etifields}" "${inst}" inst)
    # check whether it is on the exclude list
    TRIBITS_ETI_CHECK_EXCLUSION("${processed_excludes}" "${inst}" excluded)
    IF(NOT excluded) 
      STRING(REPLACE "," ";" inst ${inst})
      # append tuple to list
      FOREACH(m RANGE 1 ${num_macros})
        SET(tuple "")
        FOREACH(ind ${macroindex${m}})
          LIST(GET inst ${ind} t)
          LIST(APPEND tuple ${t})
        ENDFOREACH()
        STRING(REPLACE ";" "," tuple "${tuple}")
        LIST(APPEND macrotuples${m} ${tuple})
      ENDFOREACH()
    ENDIF()
  ENDFOREACH()
  # remove duplicates from lists
  FOREACH(m RANGE 1 ${num_macros})
    LIST(REMOVE_DUPLICATES macrotuples${m})
  ENDFOREACH()
  # build the macro strings
  FOREACH(m RANGE 1 ${num_macros})
    TRIBITS_ETI_BUILD_MACRO_STRING("${macroname${m}}" "${macrotuples${m}}" mac)
    SET(${macrovar${m}} "${mac}" PARENT_SCOPE)
  ENDFOREACH()
  # build the typedef string
  SET(${PACKAGE_NAME}_ETI_TYPEDEFS manglingtypedefmacro PARENT_SCOPE)
ENDFUNCTION()
