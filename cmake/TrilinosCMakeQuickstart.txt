------------------------------------------------------------------------------
                         Trilinos CMake Quickstart
------------------------------------------------------------------------------


Last Updated: 2009/01/11


A) Getting set up to use CMake
------------------------------

(*) Installing CMake

    $ $TRILINOS_HOME/cmake/python/install-cmake.phy --install-dir=INSTALL_BASE_DIR

  This will result in cmake and related CMake tools being installed in
  INSTALL_BASE_DIR/bin.

  Getting help:

    $ $TRILINOS_HOME/cmake/python/install-cmake.phy --help

  NOTE: you will want to read the help message about how to use sudo to
  install in a privileged location.


B) Getting Help
-----------------

(*) Finding CMake help at the website

    http://www.cmake.org

(*) Building CMake help locally

  $ cmake --help-full cmake.help.html

  (Open your web browser to the file cmake.help.html)



C) Configuring
---------------

(*) Viewing available configure-time options with documentation

  $ cd $BUILD_DIR
  $ rm CMakeCache.txt
  $ cmake -LAH -D Trilinos_ENABLE_ALL_PACKAGES:BOOL=ON \
    $TRILINOS_BASE_DIR

  NOTE: You can also just look at the text file CMakeCache.txt after any
  configure which gets created in the build directory which has all of the
  cache variables and documentation.

(*) Viewing available configure-time options without documentation

  $ cd $BUILD_DIR
  $ rm CMakeCache.txt
  $ cmake -LA SAME_AS_ABOVE $TRILINOS_BASE_DIR

(*) Configuring Trilinos to build

  a) Using ccmake:

    $ ccmake $TRILINOS_BASE_DIR

  b) [Recommended] Create a 'do-configure' scripts like:

        EXTRA_ARGS=$@
        
        cmake \
          -D CMAKE_BUILD_TYPE:STRING=DEBUG \
          -D Trilinos_ENABLE_ALL_PACKAGES:BOOL=ON \
          -D Trilinos_ENABLE_TESTS:BOOL=ON \
          -D Trilinos_ENABLE_DEBUG:BOOL=ON \
          -D DART_TESTING_TIMEOUT:STRING=600 \
          -D CMAKE_VERBOSE_MAKEFILE:BOOL=TRUE \
          $EXTRA_ARGS \
          ../../../Trilinos

      and then run it as:

        $ ./do-configure [OTHER_OPTIONS]

      See Trilinos/sampleScripts/*cmake for real examples.

(*) Configuring to build debug and release (optimized) versions:

  To build a debug version, pass into 'cmake':

    -D CMAKE_BUILD_TYPE:STRING=DEBUG

  NOTE: The above will automatically set Trilinos_ENBLE_DEBUG=ON which will
  turn on all debug checks in all packages by default.

  To build a release (optimized) version, pass into 'cmake':

    -D CMAKE_BUILD_TYPE:STRING=RELEASE

(*) Overriding debug/release compiler options:

  To pass in compiler options that override the default debug or release
  options use:

    -D CMAKE_BUILD_TYPE:STRING=NONE \
    -D CMAKE_C_FLAGS:STRING="-04 --funrool-loops" \
    -D CMAKE_CXX_FLAGS:STRING="-03 -fexceptions" \

  where LANGUAGE = C, CXX, Fortran etc.

(*) Overridding all compiler options:

  To override all compiler options, including both strong warning options and
  debug/release options use:

    -D CMAKE_BUILD_TYPE:STRING=NONE \
    -D Trilinos_ENABLE_STRONG_C_COMPILE_WARNINGS:BOOL=OFF \
    -D Trilinos_ENABLE_STRONG_CXX_COMPILE_WARNINGS:BOOL=OFF \
    -D CMAKE_C_FLAGS:STRING="-04 --funrool-loops" \
    -D CMAKE_CXX_FLAGS:STRING="-03 -fexceptions" \

(*) Configuring Trilinos for MPI support:

  To enable MPI support you must minimally:

    -D TPL_ENABLE_MPI:BOOL=ON

  There is built-in logic to try to find the various MPI components on your
  system but you can override (or make suggestions) with:

    -D MPI_BASE_DIR:PATH="path"

      Base path where a standard MPI install in found which will have
      the subdirs 'bin', 'libs', 'include' etc.

    -D MPI_BIN_DIR:PATH="path1;path2;...;pathn"

      Paths where the MPI executables (e.g. mpiCC, mpicc, mpirun, mpiexec)
      can be found.  By default this is set to ${MPI_BASE_DIR}/bin if
      MPI_BASE_DIR is set.

  The value of LD_LIBRARY_PATH will also automatically be set to
  ${MPI_BASE_DIR}/lib if it exists.  This is needed for the basic compiler
  tests for some MPI implementations that are installed in non-standard
  locations.

  a) Configuring build using MPI compiler wrappers:

    The MPI compiler wrappers are turned on by default.  There is built-in
    logic that will try to find the right compiler wrappers.  However, you can
    specifically select them by setting:

      -D MPI_[C,CXX_Fortran] COMPILER:FILEPATH="exec_name"

        The name of the MPI C/C++/Fortran compiler wrapper executable.
        If this is just the name of the program it will be looked for
        in ${MPI_BIN_DIR} and in other standard locations with that name.
        If this is an absolute path, then this will be used as
        CMAKE_[C,CXX,Fortran]_COMPILER to compile and link code.

  b) Confiugring build using raw compilers and flags/libraries:

    While using the MPI compiler wrappers as described above is the preferred
    way to enable support for MPI, you can also just use the raw compilers and
    then pass in all of the other information that will be used to compile and
    link your code.

    To turn off the MPI compiler wrappers, set:

      -D MPI_USE_COMPILER_WRAPPERS:BOOL=ON

    ToDo: Finish documentation on how to set this up after it is fully
    implemented and tested :-)

  c) Setting up to run MPI programs

    In order to use the ctest program to run MPI tests, you must set the mpi
    run command and the options it takes.  The built-in logic will try to find
    the right program and options but you will have to override them in many
    cases.

    MPI test and example executables are run as:

      ${MPI_EXEC} ${MPI_EXEC_PRE_NUMPROCS_FLAGS} ${MPI_EXEC_NUMPROCS_FLAG} <NP> \
        ${MPI_EXEC_POST_NUMPROCS_FLAGS} <TEST_EXECUTABLE_PATH> <TEST_ARGS>

    where TEST_EXECUTABLE_PATH, TEST_ARGS, and NP are specific to the test
    being run.

    The test-independent MPI arguments are:

      -D MPI_EXEC:FILEPATH="exec_name"

        The name of the MPI run command (e.g. mpirun, mpiexec) that is used to
        run the MPI program.  The can be just the name of the program in which
        case the full path will be looked for in ${MPI_BIN_DIR} as described
        above.  If it is an absolute path, it will be used without question.

      -D MPI_EXEC_MAX_NUMPROCS:STRING=4

        The maximum number of processes to allow when setting up and running
        MPI test and example executables.  The default is set to '4' and only
        needs to be changed when needed or desired.

      -D MPI_EXEC_NUMPROCS_FLAG:STRING=-np

        The command-line option just before the number of processes to use
        <NP>.  This is given defaults based on the name of ${MPI_EXEC}.

      -D MPI_EXEC_PRE_NUMPROCS_FLAGS:STRING="arg1 arg2 ... argn"

        Other command-line arguments that must come *before* the num-proces
        argument.  The default is empty "".

      -D MPI_EXEC_POST_NUMPROCS_FLAGS:STRING="arg1 arg2 ... argn"

        Other command-line arguments that must come *after* the num-proces
        argument.  The default is empty "".


(*) Configuring Trilinos to build all packages with all tests and examples:

    $ ./do-configure \
       -D Trilinos_ENABLE_ALL_PACKAGES:BOOL=ON \
       -D Trilinos_ENABLE_TESTS:BOOL=ON

  NOTE: Specific packages can be disabled with
  Trilinos_ENABLE_PACKAGE:BOOL=OFF.

  NOTE: All examples are enabled by default when setting
  Trilinos_ENABLE_TESTS:BOOL=ON.

(*) Configuring a package(s) along with all of the packages it can use:

    $ ./do-configure \
       -D Trilinos_ENABLE_ALL_PACKAGES:BOOL=OFF \
       -D Trilinos_ENABLE_<PACKAGE>:BOOL=ON \
       -D Trilinos_ENABLE_ALL_OPTIONAL_PACKAGES:BOOL=ON \
       -D Trilinos_ENABLE_TESTS:BOOL=ON

  NOTE: This set of arguments allows a user to turn on <PACKAGE> as well as all
  packages that <PACKAGE> can use.  However, tests and examples will only be turned
  on for <PACKAGE> (or any other packages specifically enabled).

(*) Configuring Trilinos to test all effects of changing a given package(s):

  $ ./do-configure \
     -D Trilinos_ENABLE_ALL_PACKAGES:BOOL=OFF \
     -D Trilinos_ENABLE_<PACAKGE>:BOOL=ON \
     -D Trilinos_ENABLE_ALL_FORWARD_DEP_PACAKGES:BOOL=ON \
     -D Trilinos_ENABLE_TESTS:BOOL=ON

  NOTE: The above set of arguments will result in package <PACAKGE> and all
  packages that depend on <PACAKGE> to be enabled and have all of their tests
  turned on.  Tests will not be enabled in packages that do not depend on
  <PACAKGE> in this case.  This speeds up and robustifies pre-checkin testing.

(*) Enabling support for optional Third-Party Libraries (TPLs):

  Pass into 'cmake':

    -D TPL_ENABLE_<TPLNAME>:BOOL=ON

  where TPLNAME = Boost, ParMETIS, etc.

  The headers, libraries, and library directories can then be specified with:

    <TPLNAME>_INCLUDE_DIRS: List of paths to the header include directories

    <TPLNAME>_LIBRARY_NAMES: List of unadorned library names, in the order of
    the link line.  The platform-specific prefixes (e.g.. 'lib') and postfixes
    (e.g. '.a', '.lib', or '.dll') will be added automatically.

    <TPLNAME>_LIBRARY_DIRS: The list of directories where the library files
    can be found.

  NOTE: The variables TPL_<TPLNAME>_INCLUDE_DIRS and TPL_<TPLNAME>_LIBRARIES
  are what are directly used by the CMake build infrastructure.  These
  variables are normally set by the varaibles <TPLNAME>_INCLUDE_DIRS,
  <TPLNAME>_LIBRARY_NAMES, and <TPLNAME>_LIBRARY_DIRS using find commands but
  you can always override these and directly set the (FILEPATH) cache varibles
  TPL_<TPLNAME>_INCLUDE_DIRS and TPL_<TPLNAME>_LIBRARIES.  This gives the user
  complete and directl control in specifying set exactly what is used in the
  build process.

  Optional package-specific support for a TPL can be turned off by passing
  into 'cmake':

    -D <PACKAGE>_ENABLE_<TPLNAME>:BOOL=OFF

  where PACKAGE is Epetra, NOX etc.  This gives the user full control over
  what TPLs are supported by which package independently.

(*) Getting verbose output from configure

    $ ./do_configure -D Trilinos_VERBOSE_CONFIGURE:BOOL=ON

  NOTE: This produces a *lot* of output but can be very useful when debugging
  configuration problems

(*) Getting very verbose output from configure

    $ ./do_configure -D Trilinos_VERBOSE_CONFIGURE:BOOL=ON --debug-output --trace

  NOTE: This will print a complete stack trace to see exactly where you are

(*) Viewing current values of cache variables

    $ cmake -LA $TRILINOS_BASE_DIR

  or just examine and grep the file CMakeCache.txt.

(*) Reconfiguring from scratch

    $ rm CMakeCache ; ./do-configure

  NOTE: Removing the CMakeCache.txt file is often needed when removing
  variables from the configure line.

(*) Seeing configure errors

  Configure time errors are shown in the file:

      $BUILD_BASE_DIR/CMakeFiles/CMakeError.log.


D) Building
---------------

(*) Discovering what targets are available to build after configuration:

      $ make help

(*) See all of the targets to build for a package:

    $ make help | grep <PACKAGE>_

  (where PACKAGE = Teuchos, Epetra, NOX, etc.)

  or:

    $ cd packages/<PACKAGE>
    $ make help

(*) Building all of the targets for a package:

    $ make <PACKAGE>_all

  (where PACKAGE = Teuchos, Epetra, NOX, etc.)

  or:

    $ cd packages/<PACKAGE>
    $ make

(*) Building all of the libraries for a package:

    $ make <PACKAGE>_libs

  (where PACKAGE = Teuchos, Epetra, NOX, etc.)

(*) Building a single object file:

  First, look for the name of the object file to build based on the source
  file SomeSourceFile.cpp:

    $ make help | grep SomeSourceFile.o

  Build the source file:

    $ make WHATEVER_WAS_RETURNED_ABOVE


E) Testing with CTest
---------------------

(*) Using 'make test'

    $ make test

  NOTE: This is equivalent to just running 'ctest'.

(*) Using 'ctest'

    $ ctest -W 100

  (see output in Testing/Temporary/LastTest.log)

  See detailed test otuput with :

    $ ctest -VV

(*) Only running tests for a single package

  Running a single package test:

    $ ctest -W 100 -R '^<PACKAGE>_'

  (e.g. PACKAGE = Teuchos, Epetra, etc.)
  (see output in Testing/Temporary/LastTest.log)

  or:

    $ cd packages/<PACAKGE>
    $ ctest -W 100

(*) Running a single test with full output to the console:

    $ ctest -R FULL_TEST_NAME -VV

  (i.e. FULL_TEST_NAME = Teuchos_Comm_test, Epetra_MultiVector_test, etc. )

(*) Runing memory checking:

  Running memory tets for just a single package:

    $ ctest -R '^Epetra_' -T memcheck

  (see the detailed output in
  ./Testing/Temporary/LastDynamicAnalysis_DATE_TIME.log)


F) Installing
---------------

(*) Setting the install prefix at configure time

    $ ./do-configure \
      -D CMAKE_INSTALL_PREFIX:PATH=$HOME/PROJECTS/install/trilinos/mpi/opt

(*) Installing after configuration

    $ make install

    (will build all of the targets needed before the install)

(*) Uninstall

    $ make uninstall


G) Packaging
---------------

(*) Creating a tarball of the source tree:

   $ make package_source

   NOTE: The above command will tar up *everything* in the source tree (except
   for files explicitly excluded in the CMakeLists.txt files) so make sure
   that you start with a totally clean source tree before you do this.  Or,
   you could build doxygen documentation first and then tar up Trilinos and
   that would give you the source with doxygen documentation.
