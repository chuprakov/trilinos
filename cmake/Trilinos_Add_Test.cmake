

# 2008/07/09: rabartl: ToDo:
#
# (*) Support optional DIRECTORY argument
#
# (*) Support multiple ARGS keywords
#
# (*) Support an optional POSTFIX argument for naming tests with different
# ARGS keywords

INCLUDE(Parse_Variable_Arguments)

FUNCTION (TRILINOS_ADD_TEST EXE_NAME)
   
  PARSE_ARGUMENTS(
     PARSE   #prefix
     "NUM_MPI_PROCS;DIRECTORY;KEYWORDS;COMM;ARGS;NAME;PASS_REGULAR_EXPRESSION;HOST;XHOST;FAIL_REGULAR_EXPRESSION"  #lists
     "DESEND_INTO_DIR"   #options
     ${ARGN} )
  
  # Don't add the test if the host or xhost tests don't pass
  
  IF(NOT PARSE_XHOST)
    SET (PARSE_XHOST NONE)
  ENDIF()    
  LIST (FIND PARSE_XHOST ${TRILINOS_HOSTNAME} INDEX_OF_HOSTNAME_IN_XHOST_LIST)           
  IF (NOT ${INDEX_OF_HOSTNAME_IN_XHOST_LIST} EQUAL -1)
    RETURN()
  ENDIF()

  IF(NOT PARSE_HOST)
    SET (PARSE_HOST ${TRILINOS_HOSTNAME})
  ENDIF()  
  LIST (FIND PARSE_HOST ${TRILINOS_HOSTNAME} INDEX_OF_HOSTNAME_IN_HOST_LIST)                 
  IF (${INDEX_OF_HOSTNAME_IN_HOST_LIST} EQUAL -1)
    RETURN()
  ENDIF()

  # 2008/07/09: rabartl: ToDo: Above, change the logic to allow HOST and XHOST
  # to be lists!


  
  SET(EXE_BINARY_NAME "${EXE_NAME}.exe")
  IF(PARSE_NAME)
    SET(TEST_NAME "${PROJECT_NAME}-${PARSE_NAME}")
  ELSE()
    SET(TEST_NAME "${PROJECT_NAME}-${EXE_NAME}")  
  ENDIF()
  
  #If KEYWORDS are provided then append them to the name of the test
  IF(PARSE_KEYWORDS)
    FOREACH(KEYWORD ${PARSE_KEYWORDS})
      SET(TEST_NAME ${TEST_NAME}-${KEYWORD})
    ENDFOREACH()
  ENDIF()
  GET_TARGET_PROPERTY(EXECUTABLE_PATH ${EXE_BINARY_NAME} LOCATION)
  
  SET(ADDED_THE_TEST OFF)  
    
  IF(TRILINOS_ENABLE_MPI)
    SET(NP)
    IF(PARSE_NUM_MPI_PROCS)
      IF(${PARSE_NUM_MPI_PROCS} MATCHES [0-9]+-[0-9]+)
        
        STRING(REGEX REPLACE  "([0-9]+)-([0-9]+)" "\\1" MIN_NP ${PARSE_NUM_MPI_PROCS} )
        STRING(REGEX REPLACE  "([0-9]+)-([0-9]+)" "\\2" MAX_NP ${PARSE_NUM_MPI_PROCS} )
        IF(${MIN_NP} LESS ${MPIEXEC_MAX_NUMPROCS} AND  ${MAX_NP} GREATER ${MPIEXEC_MAX_NUMPROCS} )
            SET(NP ${MPI_NUMPROCS_FLAG} ${MPIEXEC_MAX_NUMPROCS})
        ELSEIF(${MIN_NP} EQUAL ${MPIEXEC_MAX_NUMPROCS})
            SET(NP ${MPI_NUMPROCS_FLAG} ${MIN_NP})
        ELSEIF(${MAX_NP} EQUAL ${MPIEXEC_MAX_NUMPROCS})
            SET(NP ${MPI_NUMPROCS_FLAG} ${MAX_NP})
        ELSEIF(${MAX_NP} LESS ${MPIEXEC_MAX_NUMPROCS})
            SET(NP ${MPI_NUMPROCS_FLAG} ${MAX_NP})
        ELSE()
           RETURN() #The number of available processor is outside the given range
                    #so the test should not be run
        ENDIF()
      ELSE()
        IF(${PARSE_NUM_MPI_PROCS} LESS ${MPIEXEC_MAX_NUMPROCS})
          SET(NP ${MPI_NUMPROCS_FLAG} ${PARSE_NUM_MPI_PROCS})
        ELSE()
           SET(NP ${MPI_NUMPROCS_FLAG} ${MPIEXEC_MAX_NUMPROCS})
        ENDIF()
      ENDIF()
    ENDIF()
    
   
    IF (NOT PARSE_COMM)
      # If no COMM is given assume we will add the test
      SET(DO_MPI_INDEX 0)
    ELSE()
      # Else, if COMM is defined we have to find 'mpi'
      LIST (FIND PARSE_COMM "mpi" DO_MPI_INDEX)
    ENDIF()
    IF(NOT ${DO_MPI_INDEX} EQUAL -1)
      SET(TEST_NAME "${TEST_NAME}-MPI")
      
      SET(COUNTER 0)
      IF(PARSE_ARGS)
        FOREACH(PARSE_ARG ${PARSE_ARGS})
          
          
          ADD_TEST(${TEST_NAME}_${COUNTER} ${MPI_EXECUTABLE} ${NP} ${EXECUTABLE_PATH} ${PARSE_ARG})
          
          IF (PARSE_PASS_REGULAR_EXPRESSION AND ADDED_THE_TEST)
            SET_TESTS_PROPERTIES(${TEST_NAME}_${COUNTER} PROPERTIES PASS_REGULAR_EXPRESSION
              ${PARSE_PASS_REGULAR_EXPRESSION})
          ENDIF()
  
          IF (PARSE_FAIL_REGULAR_EXPRESSION AND ADDED_THE_TEST)
            SET_TESTS_PROPERTIES(${TEST_NAME}_${COUNTER} PROPERTIES FAIL_REGULAR_EXPRESSION
            ${PARSE_FAIL_REGULAR_EXPRESSION})
          ENDIF()
          MATH(EXPR COUNTER ${COUNTER}+1 )
        
        ENDFOREACH()
      ELSE()
        #ADD_TEST(${TEST_NAME} ${MPI_EXECUTABLE} ${MPI_EXECUTABLE_FLAGS} ${EXECUTABLE_PATH} ${PARSE_ARGS})
        ADD_TEST(${TEST_NAME} ${MPI_EXECUTABLE} ${NP} ${EXECUTABLE_PATH} ${PARSE_ARGS})
        
      ENDIF()
      
      SET(ADDED_THE_TEST ON)    
    ENDIF()
  ELSE()
    
    IF (NOT PARSE_COMM)
      # If no COMM is given assume we will add the test
      SET(DO_SERIAL_INDEX 0)
    ELSE()
      # Else, if COMM is defined we have to find 'serial'
      LIST (FIND PARSE_COMM "serial" DO_SERIAL_INDEX)
    ENDIF()
    
    IF(NOT ${DO_SERIAL_INDEX} EQUAL -1)
      SET(COUNTER 0)
      IF(PARSE_ARGS)
        FOREACH(PARSE_ARG ${PARSE_ARGS})
       
          ADD_TEST(${TEST_NAME}${COUNTER} ${EXECUTABLE_PATH} ${PARSE_ARG})
          
          IF (PARSE_PASS_REGULAR_EXPRESSION AND ADDED_THE_TEST)
            SET_TESTS_PROPERTIES(${TEST_NAME}_${COUNTER} PROPERTIES PASS_REGULAR_EXPRESSION
              ${PARSE_PASS_REGULAR_EXPRESSION})
          ENDIF()
  
          IF (PARSE_FAIL_REGULAR_EXPRESSION AND ADDED_THE_TEST)
            SET_TESTS_PROPERTIES(${TEST_NAME}_${COUNTER} PROPERTIES FAIL_REGULAR_EXPRESSION
            ${PARSE_FAIL_REGULAR_EXPRESSION})
          ENDIF()
          MATH(EXPR COUNTER ${COUNTER}+1 )
        
        ENDFOREACH()
      ELSE()
        ADD_TEST(${TEST_NAME} ${EXECUTABLE_PATH} ${PARSE_ARGS})
      ENDIF()
      
     
      SET(ADDED_THE_TEST ON)    
    ENDIF()
  ENDIF()

  # 2008/07/09: rabartl: ToDo: Above, create a macho called
  # ???ITEM_EXITS_IN_LIST??(...) to simplify logic!
    
  IF (PARSE_PASS_REGULAR_EXPRESSION AND ADDED_THE_TEST  AND NOT PARSE_ARGS)
   SET_TESTS_PROPERTIES(${TEST_NAME} PROPERTIES PASS_REGULAR_EXPRESSION
     ${PARSE_PASS_REGULAR_EXPRESSION})
  ENDIF()
  
  IF (PARSE_FAIL_REGULAR_EXPRESSION AND ADDED_THE_TEST AND NOT PARSE_ARGS)
   SET_TESTS_PROPERTIES(${TEST_NAME} PROPERTIES FAIL_REGULAR_EXPRESSION
     ${PARSE_FAIL_REGULAR_EXPRESSION})
  ENDIF()

  
ENDFUNCTION(TRILINOS_ADD_TEST)

